## $Id$
##
## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.  
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

## read config variables:
#include "config.wml"
#include "configbis.wml"
#include "cdswmllib.wml"

## start Python:
<protect>#!</protect><PYTHON>
<protect># -*- coding: utf-8 -*-</protect>
<protect>## $Id$</protect>
<protect>## DO NOT EDIT THIS FILE!  IT WAS AUTOMATICALLY GENERATED FROM CDSware WML SOURCES.</protect>
"""
BibRecord - xml data processing system for CDSware
"""
## fill config variables:
pylibdir = "<LIBDIR>/python"

<protect>  
## import interesting modules:
try:
    import sys
    from xml.dom import Node
    from xml.sax.saxutils import escape
    from zlib import decompress
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)
    
try:
    from Ft.Xml.Domlette import NonvalidatingReader
    is4Suite = 1
except ImportError,e :
    try:
        from xml.dom.minidom import parseString
        is4Suite = 0
    except ImportError,e :
        print "Error: %s" % e
        import sys
        sys.exit(1)

try:
    sys.path.append('%s' % pylibdir)
    from cdsware.config import *
    from cdsware.dbquery import run_sql
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

def create_record(xmltext):
    """
    creates a record object and returns it
    uses 4Suite domlette if installed else uses xml.dom.minidom
    """
    global is4Suite
    try:
        if is4Suite:
            rec = create_record_4suite(xmltext)
        else:
            rec = create_record_minidom(xmltext)
    except:
        return None
    return rec

def create_record_minidom(xmltext):
    """
    creates a record object and returns it
    uses xml.dom.minidom
    """
    record = {}
    record["fields"] = []
    dom = parseString(xmltext)
    root = dom.childNodes[0]
    for controlfield in get_childs_by_tag_name(root,"controlfield"):
        record["fields"].append(create_field(controlfield.getAttribute("tag"),get_string_value(controlfield)))
    for datafield in get_childs_by_tag_name(root,"datafield"):
        record["fields"].append(create_field(datafield.getAttribute("tag"),"",datafield.getAttribute("ind1"),datafield.getAttribute("ind2")))
        myfield = record["fields"][len(record["fields"])-1]
        for subfield in get_childs_by_tag_name(datafield,"subfield"):
            field_add_subfield(myfield,subfield.getAttribute("code"),get_string_value(subfield))
    return record

def create_record_4suite(xmltext):
    """
    creates a record object and returns it
    uses 4Suite domlette
    """
    record = {}
    record["fields"] = []
    dom = NonvalidatingReader.parseString(xmltext,"urn:dummy")
    root = dom.childNodes[0]
    for controlfield in get_childs_by_tag_name(root,"controlfield"):
        record["fields"].append(create_field(controlfield.getAttributeNS(None,"tag"),get_string_value(controlfield)))
    for datafield in get_childs_by_tag_name(root,"datafield"):
        record["fields"].append(create_field(datafield.getAttributeNS(None,"tag"),"",datafield.getAttributeNS(None,"ind1"),datafield.getAttributeNS(None,"ind2")))
        myfield = record["fields"][len(record["fields"])-1]
        for subfield in get_childs_by_tag_name(datafield,"subfield"):
            field_add_subfield(myfield,subfield.getAttributeNS(None,"code"),get_string_value(subfield))
    return record

def record_order_fields(rec,fun="order_by_tag"):
    """orders field inside record 'rec' according to a function"""
    rec["fields"].sort(eval(fun))
    return

def record_order_subfields(rec,fun="order_by_code"):
    """orders subfield inside record 'rec' according to a function"""
    for field in rec['fields']:
        field['subfields'].sort(eval(fun))
    return
    
def record_get_field_instances(rec):
    """returns the list of fields stored in record 'rec'"""
    return rec["fields"]

def record_has_field(rec,tag):
    """checks whether record 'rec' contains tag 'tag'"""
    for field in rec["fields"]:
        if field["tag"] == tag:
            return 1
    return 0
        
def record_add_field(rec,tag,value,ind1="",ind2=""):
    """
    adds new field defined by the tag|value|ind1|ind2 parameters to record 'rec'
    returns the new field
    """
    newfield = create_field(tag,value,ind1,ind2)
    rec["fields"].append(newfield)
    return newfield
        
def record_delete_field(rec,tag,ind1="",ind2=""):
    """
    delete all fields defined with marc tag 'tag' and indicators 'ind1' and 'ind2'
    from record 'rec'
    """
    newlist = []
    for field in rec["fields"]:
        if not (field["tag"]==tag and field["ind1"]==ind1 and field["ind2"]==ind2):
            newlist.append(field)
    rec["fields"] = newlist
        
def record_get_field_value(rec,tag,ind1="",ind2="",code=""):
    """
    retrieves the value of the first field containing tag 'tag' and indicators 'ind1' and 'ind2'
    inside record 'rec'. Returns the found value as a string. If no matching field is found
    returns the empty string.
    """
    for field in rec["fields"]:
        if field["tag"]==tag and field["ind1"]==ind1 and field["ind2"]==ind2:
            if field["value"] != "":
                return field["value"]
            else:
                for subfield in field["subfields"]:
                    if subfield["code"]==code:
                        return subfield["value"]
    return ""

def record_get_field_values(rec,tag,ind1="",ind2="",code=""):
    """
    retrieves the values of all the fields containing tag 'tag' and indicators 'ind1' and 'ind2'
    inside record 'rec'. Returns the found values as a list. If no matching field is found
    returns an empty list.
    """
    tmp = []
    for field in rec["fields"]:
        if field["tag"]==tag and field["ind1"]==ind1 and field["ind2"]==ind2:
            if field["value"] != "":
                tmp.append(field["value"])
            else:
                for subfield in field["subfields"]:
                    if subfield["code"]==code:
                        tmp.append(subfield["value"])
    return tmp

def record_xml_output(rec):
    """generates the XML for record 'rec' and returns it as a string"""
    xmltext = "<record>\n"
    record_order_fields(rec)
    for field in rec["fields"]:
        xmltext = "%s%s" % (xmltext,field_xml_output(field))
    xmltext = "%s</record>" % xmltext
    return xmltext
    
def create_field(tag,value,ind1="",ind2=""):
    """ creates a field object and returns it"""
    field = {}
    field["subfields"] = []
    field["tag"] = tag
    field["ind1"] = ind1
    field["ind2"] = ind2
    if type(value).__name__ in ["int","long"] :
        field["value"] = str(value)
    else:
        field["value"] = value
    return field
        
def field_get_subfield_instances(field):
    """returns the list of subfields associated with field 'field'"""
    return field["subfields"]
        
def field_add_subfield(field,code,value):
    """adds a subfield to field 'field'"""
    field["subfields"].append(create_subfield(code,value))
        
def field_xml_output(field):
    """generates the XML for field 'field' and returns it as a string"""
    xmltext = ""
    if field["value"] != "":
        xmltext = "%s  <controlfield tag=\"%s\">%s</controlfield>\n" % (xmltext,field["tag"],escape(field["value"]))
    else:
        xmltext = "%s  <datafield tag=\"%s\" ind1=\"%s\" ind2=\"%s\">\n" % (xmltext,field["tag"],field["ind1"],field["ind2"])
        for subfield in field["subfields"]:
            xmltext = "%s%s" % (xmltext,subfield_xml_output(subfield))
        xmltext = "%s </datafield>\n" % xmltext
    return xmltext
        
def create_subfield(code,value):
    """ creates a subfield object and returns it"""
    subfield = {}
    subfield["code"] = code
    if type(value).__name__ in ["int","long"]:
        subfield["value"] = str(value)
    else:
        subfield["value"] = value
    return subfield
    
def subfield_xml_output(subfield):
    """generates the XML for a subfield object and return it as a string"""
    xmltext = "    <subfield code=\"%s\">%s</subfield>\n" % (subfield["code"],escape(subfield["value"]))
    return xmltext
        
def order_by_tag(field1, field2):
    """function used to order the fields according to their tag value"""
    return cmp(field1["tag"], field2["tag"])
    
def order_by_code(subfield1,subfield2):
    """function used to order the subfields according to their code value"""
    return cmp(subfield1['code'],subfield2['code'])
    
def get_childs_by_tag_name(node, local):
    """retrieves all childs from node 'node' with name 'local' and returns them as a list"""
    res=[]
    for child in node.childNodes:
        if child.localName == local:
            res.append(child)
    return res

def get_string_value(node):
    """gets all child text nodes of node 'node' and returns them as a unicode string"""
    text_nodes = node.childNodes
    return u''.join([ n.data for n in text_nodes ])
    
def db_get_xml_record(recid,format='xm'):
    """extracts record #newid xml representation from the db and returns it as a string"""
    res = run_sql("SELECT value FROM bibfmt WHERE format=%s and id_bibrec=%s",(format,recid,))
    if len(res) > 0:
        return decompress(res[0][0])
    return ""
        
</protect>