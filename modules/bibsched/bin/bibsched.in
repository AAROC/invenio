## $Id$
## Script that takes care of the task queue

## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.  
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

## read config variables:
#include "config.wml"
#include "configbis.wml"

## start Python:
<protect>#!</protect><PYTHON>
<protect>## $Id$</protect>
<protect>## DO NOT EDIT THIS FILE!  IT WAS AUTOMATICALLY GENERATED FROM CDSware WML SOURCES.</protect>
"""Keeps a queue of pending tasks and dispatchs them to helper modules.

Author:   eduardo.margallo@cern.ch
Modifyer: thomas.baron@cern.ch

"""
## fill config variables:
pylibdir = "<LIBDIR>/python"

## okay, rest of the Python code goes below
#######

## version number:
__version__ = "$Id$"


<protect>  
## import interesting modules:
try:
    import os
    import imp
    import string
    import sys
    import MySQLdb
    import time
    import re
    import getopt
    import curses
    import curses.panel
    from curses.wrapper import wrapper
    import signal
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

try:
    sys.path.append('%s' % pylibdir)
    from cdsware.config import *
    from cdsware.dbquery import run_sql
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

runtimelogdir = tmpdir


dbg = 1
path = "."

def get_date( var, format_string = "%Y-%m-%d %H:%M:%S" ):
    date = time.time()
    shift_re=re.compile( "([-\+]{0,1})([\d]+)([dhms])" )
    factors = {"d":24*3600, "h":3600, "m":60, "s":1}
    if not var: return ""
    m = shift_re.match( var )
    if m:
        sign = m.groups()[0] == "-" and -1 or 1
        factor = factors[m.groups()[2]]
        value = float(m.groups()[1])
        date = time.localtime( date + sign * factor * value )
        date = time.strftime( format_string, date )
    else:
        return ""
    return date

def get_my_pid(process,args=''):
    COMMAND = "ps -C %s o '%%p%%a' | grep '%s %s' | sed -n 1p" % (process,process,args)
    answer = string.strip(os.popen(COMMAND).read())
    if answer=='':
        answer = 0
    else:
        answer = answer[:string.find(answer,' ')]
    return int(answer)
        
class Manager:
    def __init__(self):
        self.helper_modules = ["bibwords","bibupload","bibreformat"]
        self.db = MySQLdb.connect(host=dbhost, db=dbname, user=dbuser, passwd=dbpass)
        self.cursor = self.db.cursor()
        self.cursor_bis = self.db.cursor()
        self.running = 1
        self.footer_move_mode = "[KeyUp/KeyDown Move] [M Select mode] [Q Quit]"
        self.footer_auto_mode = "[A Manual mode] [1/2 Display Type] [Q Quit]"
        self.footer_select_mode = "[KeyUp/KeyDown/PgUp/PgDown Select] [L View Log] [1/2 Display Type] [M Move mode] [A Auto mode] [Q Quit]"
        self.footer_waiting_item = "[R Run] [D Delete]"
        self.footer_running_item = "[S Sleep] [T Stop] [K Kill]"
        self.footer_stopped_item = "[I Initialise] [D Delete]"
        self.footer_sleeping_item   = "[W Wake Up]"
        self.item_state = ""
        self.selected_line = 2
        self.rows = []
        self.panel = None
        self.display = 2
        self.first_visible_line = 0
        self.move_mode = 0
        self.auto_mode = 0
        self.bibsched_daemon_id = 0
        self.currentrow = ["","","","","","",""]
        wrapper( self.start )
        
    def handle_keys(self):
        chr = self.stdscr.getch()
        if chr == -1:
            return
        if self.auto_mode and (chr not in (curses.KEY_UP,curses.KEY_DOWN,curses.KEY_PPAGE,curses.KEY_NPAGE,ord("q"),ord("Q"),ord("a"),ord("A"),ord("1"),ord("2"))):
            self.put_footer("in automatic mode")
            self.stdscr.refresh()
        elif self.move_mode and (chr not in (curses.KEY_UP,curses.KEY_DOWN,ord("m"),ord("M"),ord("q"),ord("Q"))):
            self.put_footer("in move mode")
            self.stdscr.refresh()
        else:
            if chr == curses.KEY_UP:
                if self.move_mode:
                    self.move_up()
                else:
                    self.selected_line = max( self.selected_line - 1 , 2 )
                self.repaint()
            if chr == curses.KEY_PPAGE:
                self.selected_line = max( self.selected_line - 10 , 2 )
                self.repaint()
            elif chr == curses.KEY_DOWN:
                if self.move_mode:
                    self.move_down()
                else:
                    self.selected_line = min(self.selected_line + 1, len(self.rows) + 1 )
                self.repaint()
            elif chr == curses.KEY_NPAGE:
                self.selected_line = min(self.selected_line + 10, len(self.rows) + 1 )
                self.repaint()
            elif chr == curses.KEY_HOME:
                self.first_visible_line = 0
                self.selected_line = 2
            elif chr in (ord("a"), ord("A")):
                self.change_auto_mode()
            elif chr in (ord("l"), ord("L")):
                self.openlog()
            elif chr in (ord("w"), ord("W")):
                self.wakeup()
            elif chr in (ord("r"), ord("R")):
                self.run()
            elif chr in (ord("s"), ord("S")):
                self.sleep()
            elif chr in (ord("k"), ord("K")):
                self.kill()
            elif chr in (ord("t"), ord("T")):
                self.stop()
            elif chr in (ord("d"), ord("D")):
                self.delete()
            elif chr in (ord("i"), ord("I")):
                self.init()
            elif chr in (ord("m"), ord("M")):
                self.change_select_mode()
            elif chr == ord("1"):
                self.display = 1
                self.first_visible_line = 0
                self.selected_line = 2
                self.put_footer("only done processes are displayed")
            elif chr == ord("2"):
                self.display = 2
                self.first_visible_line = 0
                self.selected_line = 2
                self.put_footer("only not done processes are displayed")
            elif chr in (ord("q"), ord("Q")):
                if curses.panel.top_panel() == self.panel:
                    self.panel.bottom()
                    curses.panel.update_panels()
                else:
                    self.running = 0
                    return

    def set_state(self, id, state):
        update_query = "UPDATE schTASKS set state='%s' WHERE id='%d'" % (state, id)
        self.cursor.execute( update_query )
        
    def set_progress(self, id, progress):
        update_query = "UPDATE schTASKS set progress='%s' WHERE id='%d'" % (progress, id)
        self.cursor.execute( update_query )
        
    def openlog(self):
        self.win = curses.newwin( self.height-2, self.width-2, 1, 1 )
        self.panel = curses.panel.new_panel( self.win )
        self.panel.top()
        self.win.border()
        self.win.addstr(1, 1, "Not implemented yet...")
        self.win.refresh()
        curses.panel.update_panels()

    def count_processes(self,state):
        query = "SELECT COUNT(id) FROM schTASKS WHERE state='%s' GROUP BY state" % state
        self.cursor.execute(query)
        row = self.cursor.fetchone()
        if row:
            return row[0]
        else:
            return 0

    def get_output_channels(self,id):
        query = "SELECT output,error FROM schTASKS WHERE id=%s" % id
        self.cursor.execute(query)
        row = self.cursor.fetchone()
        if row:
            return row
        else:
            return ['','']
        
    def wakeup(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if process == "bibupload":
            arg2 = "-t "
        else:
            arg2 = ""
        if self.count_processes('RUNNING') + self.count_processes('CONTINUING') >= 1:
            self.put_footer("a process is already running!")
        elif state == "SLEEPING":
            mypid = get_my_pid(process,"%s%s" % (arg2, str(id)))
            if mypid!=0:
                os.kill(mypid, signal.SIGCONT)
            self.put_footer("process woken up")
        else:
            self.put_footer("process is not sleeping")
        self.stdscr.refresh()

    def run(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        sleeptime = self.currentrow[4]
        if self.count_processes('RUNNING') + self.count_processes('CONTINUING') >= 1:
            self.put_footer("a process is already running!")
        elif state == "STOPPED" or state == "WAITING":
            name = "%s/%s_%s" % (runtimelogdir,process,time.strftime('%Y%m%d_%H%M%S'))
            [fdout,fderr] = self.get_output_channels(id)
            if fdout == '' or fdout == 'None':
                fdout = name + ".out"
            if fderr == '' or fderr == 'None':
                fderr = name + ".err"
            update_query="""UPDATE schTASKS set output='%s',
            error='%s' WHERE id='%d'""" % (fdout, fderr, id )
            self.cursor.execute(update_query)
            if process in self.helper_modules:
                program=os.path.join( bindir, process )
                if process == "bibupload":
                    arg2 = "-t "
                else:
                    arg2 = ""
                COMMAND = "%s %s %s >> %s 2>> %s &" % (program, arg2, str(id), fdout, fderr)
                os.system(COMMAND)
                next_date=MySQLdb.escape_string(get_date(sleeptime))
                if next_date:
                    insert_query="""INSERT INTO schTASKS(
                    proc, user, date, sleeptime, arguments, state, score)
                    VALUES ('%s','%s','%s','%s','%s','WAITING','%d')""" % (process,self.currentrow[2], MySQLdb.escape_string(get_date(sleeptime)),sleeptime,self.currentrow[7],self.currentrow[8])
                    self.cursor.execute(insert_query)
        else:
            self.put_footer("process state should be STOPPED or WAITING!")
        self.stdscr.refresh()

    def sleep(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if process == "bibupload":
            arg2 = "-t "
        else:
            arg2 = ""
        if state!='RUNNING' and state!='CONTINUING':
            self.put_footer("this process is not running!")
        else:
            mypid = get_my_pid(process,"%s%s" % (arg2, str(id)))
            if mypid!=0:
                os.kill(mypid, signal.SIGUSR1)
                self.put_footer("SLEEP signal sent to process #%s" % mypid)
            else:
                self.set_state(id,'STOPPED')
                self.put_footer("cannot find process...")
        self.stdscr.refresh()
        
    def kill(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if process == "bibupload":
            arg2 = "-t "
        else:
            arg2 = ""
        mypid = get_my_pid(process,"%s%s" % (arg2, str(id)))
        if mypid!=0:
            os.kill(mypid, signal.SIGKILL)
            self.set_state(id,'STOPPED')
            self.put_footer("KILL signal sent to process #%s" % mypid)
        else:
            self.set_state(id,'STOPPED')
            self.put_footer("cannot find process...")
        self.stdscr.refresh()
    
    def stop(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if process == "bibupload":
            arg2 = "-t "
        else:
            arg2 = ""
        mypid = get_my_pid(process,"%s%s" % (arg2, str(id)))
        if mypid!=0:
            os.kill(mypid, signal.SIGINT)
            self.put_footer("INT signal sent to process #%s" % mypid)
        else:
            self.set_state(id,'STOPPED')
            self.put_footer("cannot find process...")
        self.stdscr.refresh()
    
    def delete(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if state!='RUNNING' and state!='CONTINUING' and state!='SLEEPING':
            self.set_state(id,"%s_DELETED" % state)
            self.put_footer("process deleted")
            self.selected_line = max(self.selected_line - 1, 2)
        else:
            self.put_footer("cannot delete running processes")
        self.stdscr.refresh()
    
    def init(self):
        id = self.currentrow[0]
        process = self.currentrow[1]
        state = self.currentrow[5]
        if state!='RUNNING' and state!='CONTINUING' and state!='SLEEPING':
            self.set_state(id,"WAITING")
            self.set_progress(id,"None")
            self.put_footer("process initialised")
        else:
            self.put_footer("cannot initialise running processes")
        self.stdscr.refresh()

    def change_select_mode(self):
        if self.move_mode:
            self.move_mode = 0
        else:
            state = self.currentrow[5]
            if state in ( "RUNNING" , "CONTINUING" , "SLEEPING" ):
                self.put_footer("cannot move running processes!")
            else:
                self.move_mode = 1
        self.stdscr.refresh()

    def change_auto_mode(self):
        if self.auto_mode:
            if self.bibsched_daemon_id != 0:
                os.kill(self.bibsched_daemon_id,signal.SIGKILL)
            else:
                self.put_footer('Cannot find daemon process')
            self.auto_mode = 0
        else:
            name = "%s/bibsched_%s" % (runtimelogdir,time.strftime('%Y%m%d_%H%M%S'))
            fderr = name + ".err"
            fdout = name + ".out"
            program = os.path.join( bindir, "bibsched")
            COMMAND = "%s -d >> %s 2>> %s &" % (program, fdout, fderr)
            os.system(COMMAND)
            self.bibsched_daemon_id = get_my_pid("bibsched","-d")
            self.auto_mode = 1
            self.move_mode = 0
        self.stdscr.refresh()

    def move_up(self):
        self.put_footer("not implemented yet")
        self.stdscr.refresh()

    def move_down(self):
        self.put_footer("not implemented yet")
        self.stdscr.refresh()
    
    def put_line(self, row):
        col_w = [ 5 , 11 , 21 , 21 , 7 , 11 , 25 ]
        maxx = self.width
        if self.y == self.selected_line - self.first_visible_line and self.y > 1:
            if self.auto_mode:
                attr = curses.color_pair(2) + curses.A_STANDOUT + curses.A_BOLD
            elif self.move_mode:
                attr = curses.color_pair(7) + curses.A_STANDOUT + curses.A_BOLD
            else:
                attr = curses.color_pair(8) + curses.A_STANDOUT + curses.A_BOLD
            self.item_state = row[5]
            self.currentrow = row
        elif self.y == 0:
            if self.auto_mode:
                attr = curses.color_pair(2) + curses.A_STANDOUT + curses.A_BOLD
            elif self.move_mode:
                attr = curses.color_pair(7) + curses.A_STANDOUT + curses.A_BOLD
            else:
                attr = curses.color_pair(8) + curses.A_STANDOUT + curses.A_BOLD
        elif row[5] == "DONE":
            attr = curses.color_pair(5) + curses.A_BOLD
        elif row[5] == "STOPPED":
            attr = curses.color_pair(6) + curses.A_BOLD
        elif row[5] == "ERROR":
            attr = curses.color_pair(4) + curses.A_BOLD
        elif row[5] == "WAITING":
            attr = curses.color_pair(3) + curses.A_BOLD
        elif row[5] in ("RUNNING","CONTINUING") :
            attr = curses.color_pair(2) + curses.A_BOLD
        else:
            attr = curses.A_BOLD
        myline = str(row[0]).ljust(col_w[0])
        myline += str(row[1]).ljust(col_w[1])
        myline += str(row[2]).ljust(col_w[2])
        myline += str(row[3])[:19].ljust(col_w[3])
        myline += str(row[4]).ljust(col_w[4])
        myline += str(row[5]).ljust(col_w[5])
        myline += str(row[6]).ljust(col_w[6])
        myline = myline.ljust(maxx)
        self.stdscr.addnstr(self.y, 0, myline, maxx, attr)
        self.y = self.y+1

    def put_footer(self, footer, i = 0):
        maxx = self.stdscr.getmaxyx()[1]
        footer = footer.ljust(maxx)
        if self.auto_mode:
            colorpair = 2
        elif self.move_mode:
            colorpair = 7
        else:
            colorpair = 1
        self.stdscr.addnstr(self.y - i, 0, footer, maxx - 1, curses.A_STANDOUT + curses.color_pair(colorpair) + curses.A_BOLD )
        
    def repaint(self):
        self.y = 0
        self.stdscr.clear()
        self.height,self.width = self.stdscr.getmaxyx()
        maxy = self.height - 2
        maxx = self.width
        self.put_line( ("ID","PROC","USER","DATE","SLEEP","STATE","PROGRESS") )
        self.put_line( ("---","----","----","----","-----","-----","--------") )
        if self.selected_line > maxy + self.first_visible_line - 1:
            self.first_visible_line = self.selected_line - maxy + 1
        if self.selected_line < self.first_visible_line + 2:
            self.first_visible_line = self.selected_line - 2
        for row in self.rows[self.first_visible_line:self.first_visible_line+maxy-2]:
            id,proc,user,date,sleeptime,state,progress,arguments,score = row
            self.put_line( row )
        self.y = self.stdscr.getmaxyx()[0] - 1
        if self.auto_mode:
            self.put_footer(self.footer_auto_mode)
        elif self.move_mode:
            self.put_footer(self.footer_move_mode)
        else:
            self.put_footer(self.footer_select_mode)
            footer2 = ""
            if self.item_state == "DONE" or self.item_state == "ERROR" or self.item_state == "STOPPED":
                 footer2 += self.footer_stopped_item
            elif self.item_state == "RUNNING" or self.item_state == "CONTINUING":
                 footer2 += self.footer_running_item
            elif self.item_state == "SLEEPING":
                 footer2 += self.footer_sleeping_item
            elif self.item_state == "WAITING":
                 footer2 += self.footer_waiting_item
            self.put_footer(footer2,1)
        self.stdscr.refresh()
        
    def start(self, stdscr):
        ring = 0
        curses.start_color()
        curses.init_pair(8, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_RED)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_BLUE, curses.COLOR_BLACK)
        curses.init_pair(6, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(7, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        self.stdscr = stdscr
        self.stdscr.nodelay(1)
        self.base_panel = curses.panel.new_panel( self.stdscr )
        self.base_panel.bottom()
        curses.panel.update_panels()
        self.height,self.width = stdscr.getmaxyx()
        self.stdscr.clear()
        self.bibsched_daemon_id = get_my_pid("bibsched","-d")
        if self.bibsched_daemon_id != 0:
            self.auto_mode = 1
        if self.display == 1:
            where = "and state='DONE'"
            order = "DESC"
        else:
            where = "and state!='DONE'"
            order = "ASC"
        query = "SELECT id,proc,user,date,sleeptime,state,progress,arguments,score FROM schTASKS WHERE state NOT LIKE '%%DELETED%%' %s order by date %s" % (where,order)
        self.cursor.execute(query)
        self.rows = self.cursor.fetchall()
        self.repaint()
        while self.running:
            time.sleep( 0.1 )
            self.handle_keys()
            if ring == 10:
                if self.display == 1:
                    where = "and state='DONE'"
                    order = "DESC"
                else:
                    where = "and state!='DONE'"
                    order = "ASC"
                query = "SELECT id,proc,user,date,sleeptime,state,progress,arguments,score FROM schTASKS WHERE state NOT LIKE '%%DELETED%%' %s order by date %s" % (where,order)
                self.cursor.execute(query)
                self.rows = self.cursor.fetchall()
                ring = 0
                self.repaint()
            else:
                ring = ring+1

            
class Bibsched:
    def __init__(self):
        self.helper_modules = ["bibwords","bibupload","bibreformat"]
        self.db = MySQLdb.connect(host=dbhost, db=dbname, user=dbuser, passwd=dbpass)
        self.cursor = self.db.cursor()
        self.cursor_bis = self.db.cursor()
        self.running = {}
        self.sleep_done = {}
        self.sleep_sent ={}
        self.stop_sent = {}
        self.suicide_sent = {}
        
    def set_state(self, id, state):
        update_query = "UPDATE schTASKS set state='%s' WHERE id='%d'" % (state, id)
        self.cursor.execute( update_query )
        
    def can_run( self, proc ):
        return len( self.running.keys() ) == 0
    
    def get_running_processes(self):
        query = "SELECT id,proc,user,UNIX_TIMESTAMP(date),sleeptime,arguments,state,score,output,error FROM schTASKS WHERE state='RUNNING' or state='CONTINUING' LIMIT 1"
        self.cursor.execute(query)
        row = self.cursor.fetchone()
        if row:
            return row
        else:
            return 0

    def handle_row( self, row ):
        id,proc,user,date,sleeptime,arguments,state,score,fdout,fderr = row
        if state == "SLEEP":
            if id in self.running.keys():
                self.set_state( id, "SLEEP SENT" )
                os.kill( self.running[id], signal.SIGUSR1 )
                self.sleep_sent[id] = self.running[id]
        elif state == "SLEEPING":
            if id in self.sleep_sent.keys():
                self.sleep_done[id] = self.sleep_sent[id]
                del self.sleep_sent[id]
        if state == "WAKEUP":
            if id in self.sleep_done.keys():
                self.running[id] = self.sleep_done[id]
                del self.sleep_done[id]
                os.kill( self.running[id], signal.SIGCONT )
                self.set_state( id, "RUNNING" )
        elif state == "STOP":
            if id in self.running.keys():
                self.set_state( id, "STOP SENT" )
                os.kill( self.running[id], signal.SIGUSR2 )
                self.stop_sent[id] = self.running[id]
                del self.running[id]
        elif state == "STOPPED" and id in self.stop_sent.keys():
            del self.stop_sent[id]
        elif state == "SUICIDE":
            if id in self.running.keys():
                self.set_state( id, "SUICIDE SENT" )
                os.kill( self.running[id], signal.SIGABRT )
                self.suicide_sent[id] = self.running[id]
                del self.running[id]
        elif state == "SUICIDED" and id in self.suicide_sent.keys():
            del self.suicide_sent[ id ]
        elif state == "DONE" and id in self.running.keys():
            del self.running[id]
        elif self.can_run(proc) and state == "WAITING" and date <= time.time():
            name = "%s/%s_%s" % (runtimelogdir,proc,time.strftime('%Y%m%d_%H%M%S'))
            if (fderr == '' or fderr == 'None' or fderr == None):
                fderr = name + ".err"
            if (fdout == '' or fdout == 'None' or fdout == None):
                fdout = name + ".out"
            update_query="""UPDATE schTASKS set output='%s', error='%s' WHERE id='%d'""" % (fdout, fderr, id )
            self.cursor.execute(update_query)
            if proc in self.helper_modules:
                program=os.path.join( bindir, proc )
                if proc == "bibupload":
                    arg2 = "-t "
                else:
                    arg2 = ""
                COMMAND = "%s %s%s >> %s 2>> %s &" % (program, arg2, str(id), fdout, fderr)
                os.system(COMMAND)
                Log(COMMAND)
                self.running[id] = get_my_pid(proc,"%s%s" % (arg2, str(id)))
            next_date=MySQLdb.escape_string(get_date(sleeptime))
            if next_date:
                insert_query="""INSERT INTO schTASKS(
                proc, user, date, sleeptime, arguments, state, score)
                VALUES ('%s','%s','%s','%s','%s','WAITING','%d')""" % (proc,user, MySQLdb.escape_string(get_date(sleeptime)),sleeptime,arguments,score )
                self.cursor.execute(insert_query)
                
    def watch_loop(self):
        running_process = self.get_running_processes()
        if running_process:
            proc = running_process[ 1 ]
            id   = running_process[ 0 ]
            if proc == "bibupload":
                arg2 = "-t "
            else:
                arg2 = ""
            if get_my_pid(proc,"%s%s" % (arg2, str(id))):
            	self.running[id] = get_my_pid(proc,"%s%s" % (arg2, str(id)))
            else:
                self.set_state(id,"ERROR")
        query="""SELECT id,proc,user,UNIX_TIMESTAMP(date),sleeptime,
        arguments,state,score,output,error FROM schTASKS order by date asc"""
        self.cursor.execute(query)
        rows=self.cursor.fetchall()
        while 1:
            for row in rows:
                self.handle_row( row )
            time.sleep( 1 )
            self.cursor.execute(query)
            rows=self.cursor.fetchall()

def Log(message):
    if not dbg: return
    log=open( runtimelogdir + "/bibsched.log","a")
    log.write(time.strftime("\n%Y-%m-%d %H:%M:%S --> ", time.localtime()))
    log.write(message)
    log.close()
    
def usage( code, msg=''):
    "Prints usage for this module."
    if msg:
        sys.stderr.write("Error: %s.\n" % msg)
    print >> sys.stderr, \
    """ Usage: %s [-d,--daemon] 
    """ % sys.argv[0]
    sys.exit(code)

    
def main():
    long_flags = ["--daemon"]
    short_flags = "d"
    try:
        opts, args = getopt.getopt(sys.argv[1:], short_flags, long_flags)
    except getopt.GetoptError, err:
        Log( "Error: %s" % err)
        usage(1)
    if args:
        usage(1)
    if not opts:
        manager = Manager()
    else:
        sched = Bibsched()
        sched.watch_loop()
    sys.stderr.close()
    
if __name__ == '__main__':
    main()
</protect>