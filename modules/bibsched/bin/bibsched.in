## $Id$
## Script that takes care of the task queue

## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.  
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

## read config variables:
#include "config.wml"
#include "configbis.wml"

## start Python:
<protect>#!</protect><PYTHON>
<protect>## $Id$</protect>
<protect>## DO NOT EDIT THIS FILE!  IT WAS AUTOMATICALLY GENERATED FROM CDSware WML SOURCES.</protect>
"""Keeps a queue of pending tasks and dispatchs them to helper modules.

Author: eduardo.margallo@cern.ch

"""

## fill config variables:
runtimelogdir = """<RUNTIMELOGDIR>"""
cgibindir     = "<CGIBINDIR>"
dbutildir     = "<DBUTILDIR>"
tmpdir        = "<TMPDIR>"
runtimelogdir = tmpdir

dbhost = "<DBHOST>"
dbname = "<DBNAME>"
dbuser = "<DBUSER>"
dbpass = "<DBPASS>"

## okay, rest of the Python code goes below
#######

## version number:
__version__ = "$Id$"



import os
import imp
import string
import sys
import MySQLdb
import time
import re
import getopt
import curses
import curses.panel
from curses.wrapper import wrapper
import thread
import signal

dbg = 1
path = "."

def get_date( var, format_string = "%Y-%m-%d %H:%M:%S" ):
    date = time.time()
    shift_re=re.compile( "([-\+]{0,1})([\d]+)([dhms])" )
    factors = {"d":24*3600, "h":3600, "m":60, "s":1}
    
    if not var: return ""

    m = shift_re.match( var )
    if m:
        sign = m.groups()[0] == "-" and -1 or 1
        factor = factors[m.groups()[2]]
        value = float(m.groups()[1])
        date = time.localtime( date + sign * factor * value )
        date = time.strftime( format_string, date )
    else:
        return ""

        
    return date


class Manager:
    def __init__(self):
        self.db = MySQLdb.connect(host=dbhost, db=dbname, user=dbuser, passwd=dbpass)
        self.cursor = self.db.cursor()
        self.cursor_bis = self.db.cursor()
        self.running = 1
        <protect>self.footer = "U Up   D Down   L View Log   E Exit"</protect>
        self.selected_line = 1
        self.rows = []
        self.panel = None
        thread.start_new_thread( self.handle_keys, () )
        wrapper( self.start )

    def handle_keys(self):
        while 1:
            chr = self.stdscr.getch()
            if chr in (ord("u"), ord("U")):
                self.selected_line = max( self.selected_line -1 , 1 )
                self.repaint()
            elif chr in (ord("d"), ord("D")):
                self.selected_line = min(self.selected_line+1, len(self.rows) )
                self.repaint()
            elif chr in (ord("l"), ord("L")):
                self.openlog()
            elif chr in (ord("e"), ord("E")):
                if curses.panel.top_panel() == self.panel:
                    self.panel.bottom()
                    curses.panel.update_panels()
                else:
                    self.running = 0
                    return

    def openlog(self):
        self.win = curses.newwin( self.height-2, self.width-2, 1, 1 )
        self.panel = curses.panel.new_panel( self.win )
        self.panel.top()
        self.win.border()
        self.win.refresh()
        curses.panel.update_panels()
        

    def put_line(self, row):
        if  self.y == self.selected_line:
            attr = curses.A_STANDOUT
        else:
            attr = 0

        self.stdscr.addstr(self.y,  0, str(row[0])[:2], attr )
        self.stdscr.addstr(self.y,  5, str(row[1])[:8], attr )
        self.stdscr.addstr(self.y, 15, str(row[2])[:23], attr )
        self.stdscr.addstr(self.y, 39, str(row[3])[:19], attr )
        self.stdscr.addstr(self.y, 60, str(row[4])[:8], attr )
        self.stdscr.addstr(self.y, 70, str(row[5])[:8], attr )

        self.y = self.y+1



    def repaint(self):
        self.y = 0
        self.stdscr.clear()
        self.put_line( ("ID","PROC","USER","DATE","SLEEP","STATE" ))
        for row in self.rows:
            id,proc,user,date,sleeptime,state = row
            self.put_line( row )

        self.y = self.stdscr.getmaxyx()[0] - 1
        self.stdscr.addstr(self.y,0, self.footer )
        
        self.stdscr.refresh()

    def start(self, stdscr):
        self.stdscr = stdscr
        self.base_panel = curses.panel.new_panel( self.stdscr )
        self.base_panel.bottom()
        curses.panel.update_panels()
        self.height,self.width = stdscr.getmaxyx()
        self.y = 0
        self.stdscr.clear()
        query = "SELECT id,proc,user,date,sleeptime,state FROM schTASKS"
    
        self.cursor.execute(query)
        self.rows = self.cursor.fetchall()
    
        while self.running:
            self.repaint()
            time.sleep( 1 )
            self.cursor.execute(query)
            self.rows = self.cursor.fetchall()

class Bibsched:
    def __init__(self):
        self.helper_modules = ["bibwords"]
        self.db = MySQLdb.connect(host=dbhost, db=dbname, user=dbuser, passwd=dbpass)
        self.cursor = self.db.cursor()
        self.cursor_bis = self.db.cursor()
        self.running = {}
        self.sleep_done = {}
        self.sleep_sent ={}
        self.stop_sent = {}
        self.suicide_sent = {}
        
    def set_state(self, id, state):
        update_query = "UPDATE schTASKS set state='%s' WHERE id='%d'" % \
                       (state, id)
        self.cursor.execute( update_query )
        

    def can_run( self, proc ):
        return len( self.running.keys() ) == 0
    
    def handle_row( self, row ):
        id,proc,user,date,sleeptime,arguments,state,score = row


        if state == "SLEEP":
            if id in self.running.keys():
                self.set_state( id, "SLEEP SENT" )
                os.kill( self.running[id], signal.SIGUSR1 )
                self.sleep_sent[id] = self.running[id]

        elif state == "SLEEPING":
            if id in self.sleep_sent.keys():
                self.sleep_done[id] = self.sleep_sent[id]
                del self.sleep_sent[id]

        if state == "WAKEUP":
            if id in self.sleep_done.keys():
                self.running[id] = self.sleep_done[id]
                del self.sleep_done[id]
                os.kill( self.running[id], signal.SIGCONT )
                self.set_state( id, "RUNNING" )
            
        elif state == "STOP":
            if id in self.running.keys():
                self.set_state( id, "STOP SENT" )
                os.kill( self.running[id], signal.SIGUSR2 )
                self.stop_sent[id] = self.running[id]
                del self.running[id]
            
        elif state == "STOPPED" and id in self.stop_sent.keys():
            os.waitpid( self.stop_sent[id], 0 )
            del self.stop_sent[id]
            
        elif state == "SUICIDE":
            if id in self.running.keys():
                self.set_state( id, "SUICIDE SENT" )
                os.kill( self.running[id], signal.SIGABRT )                
                self.suicide_sent[id] = self.running[id]
                del self.running[id]
            
        elif state == "SUICIDED" and id in self.suicide_sent.keys():
            os.waitpid( self.suicide_sent[id], 0 )
            del self.suicide_sent[ id ]
            
        elif state == "DONE" and id in self.running.keys():
            os.waitpid( self.running[id], 0 )
            del self.running[id]

        elif self.can_run(proc) and state == "WAITING" and date <= time.time():
            name = os.tempnam()
            update_query = """UPDATE schTASKS set output='%s',
            error='%s' WHERE id='%d'""" % \
            (name + ".out", name + ".err", id )
            self.cursor.execute(update_query)

            if proc in self.helper_modules:
                pid = os.fork()
                if pid:
                    self.running[id]=pid
                else:
                    fderr = open( name + ".err", "w" )
                    fdout = open( name + ".out", "w" )
                    os.dup2(fderr.fileno(), sys.stderr.fileno())
                    os.dup2(fdout.fileno(), sys.stdout.fileno())
                    program = os.path.join( os.getcwd(), proc )
                    os.execv( program, (program,str(id) ))
            next_date = MySQLdb.escape_string(get_date(sleeptime))

            if next_date:
                insert_query = """INSERT INTO schTASKS(
                proc, user, date, sleeptime, arguments, state, score)
                VALUES ('%s','%s','%s','%s','%s','WAITING','%d')""" % \
                (proc,user, \
                 MySQLdb.escape_string(get_date(sleeptime)),\
                 sleeptime,arguments,score )
                self.cursor.execute(insert_query)

        
    def watch_loop(self):
        query = """SELECT id,proc,user,UNIX_TIMESTAMP(date),sleeptime,
        arguments,state,score FROM schTASKS"""

        self.cursor.execute(query)
        rows = self.cursor.fetchall()
    
        while 1:
            for row in rows:
                self.handle_row( row )
            time.sleep( 1 )
            self.cursor.execute(query)
            rows = self.cursor.fetchall()

            

def Log(message):
    # log in file
    if not dbg: return
    log = open( runtimelogdir + "/bibsched.log","a")
    log.write(time.strftime("\n%Y-%m-%d %H:%M:%S --> ", localtime()))
    log.write(message)
    log.close()

def usage( code, msg=''):
    "Prints usage for this module."
    if msg:
        sys.stderr.write("Error: %s.\n" % msg)
<protect>
    print >> sys.stderr, \
    """ Usage: %s [-d,--daemon] 
    """ % sys.argv[0]
</protect>
    sys.exit(code)

def main():
    long_flags = ["--daemon"]
    short_flags = "d"
    try:
        opts, args = getopt.getopt(sys.argv[1:], short_flags, long_flags)
    except getopt.GetoptError, err:
        Log( "Error", err)
        usage(1)
    if args:
        usage(1)
        
    if not opts:
        manager = Manager()
    else:
        sched = Bibsched()
        # Change standard error output
        #sys.stderr = open( runtimelogdir + "/bibsched.err","a")
        sched.watch_loop()

    

    sys.stderr.close()
    
### okay, here we go:
if __name__ == '__main__':
    main()
