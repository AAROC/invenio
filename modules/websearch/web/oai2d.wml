## $Id$
## OAI interface for CDSware/MySQL written in Python compliant with OAI-PMH2.0

## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

## read config variables:
#include "config.wml"
#include "configbis.wml"

## start Python:
<protect>#!</protect><PYTHON>
<protect>## $Id$</protect>
<protect>## DO NOT EDIT THIS FILE!  IT WAS AUTOMATICALLY GENERATED FROM CDSware WML SOURCES.</protect>
"""OAI interface for CDSware/MySQL written in Python compliant with OAI-PMH2.0"""

## fill config variables:
dbhost                 = """<DBHOST>"""
dbname                 = """<DBNAME>"""
dbuser                 = """<DBUSER>"""
dbpass                 = """<DBPASS>"""
cdsname                = """<CDSNAME>"""
supportemail           = """<SUPPORTEMAIL>"""
runtimelogdir          = """<LOGDIR>"""
cgibinurl              = """<CGIBINURL>"""

## OAI config variables
oaiidprefix            = """<OAIIDPREFIX>"""
oaisampleidentifier    = """<OAISAMPLEIDENTIFIER>"""
oaiidentifydescription = """<OAIIDENTIFYDESCRIPTION>"""
oaiidfield             = "909COo"
oaisetfield            = "909COp"

lastmodified           = """<: print `date +"%d %b %Y %H:%M:%S %Z"`; :>"""

<protect>
## okay, rest of the Python code goes below
#######

__version__ = "$Id$"

## import interesting modules:
try:
    import cgi
    import cPickle
    import string
    from string import split
    import os
    import re
    import sys
    import time
    import MySQLdb
    import md5
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)    

## config:
nb_records_in_resume     = 100 	 # limit for items of OAI ListRecords
nb_identifiers_in_resume = 100 	 # limit for items of OAI ListIdentifiers
oai_rt_expire            = 90000 # OAI resumptionToken expiration (seconds)

## connect to MySQL
db = MySQLdb.connect(host=dbhost, db=dbname, user=dbuser, passwd=dbpass)
cursor = db.cursor()

## precompile some often-used regexp for speed reasons:
re_amp = re.compile('&')

def encode_for_xml(s):
    "Encode special chars in string so that it would be XML-compliant."

    s = string.replace(s, '&', '&amp;')
    s = string.replace(s, '<', '&lt;')
    return s


def print_oai_header(verb):
    "Print OAI header"

    print "Content-type: text/xml\n"
    print """<?xml version="1.0" encoding="UTF-8"?>"""
    print """
<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/
         http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
    """

    print " <responseDate>" + OAIGetResponseDate() + "</responseDate>"
    if verb:
        print """ <request verb="%s">%s</request>""" % (verb,OAIGetRequestURL())
        print " <%s>" % verb
    else:
        print """ <request>%s</request>""" % (OAIGetRequestURL())


def print_oai_footer(verb):
    "Print OAI footer"

    if verb:
	print """ </%s>""" % verb
    print """</OAI-PMH>"""

def get_field(sysno, field):
    "Gets list of field 'field' for the record with 'sysno' system number."

    out   = []
    digit = field[0:2]

    bx    = "bib%sx" % digit
    bibx  = "bibrec_bib%sx" % digit
    query = "SELECT bx.value FROM %s AS bx, %s AS bibx WHERE bibx.id_bibrec='%s' AND bx.id=bibx.id_bibxxx AND bx.tag='%s'" % (bx, bibx, sysno, field)

    cursor.execute(query)
    row = cursor.fetchone()
    while row:
        out.append(row[0])
        row = cursor.fetchone()
    return out


def UTC_to_localtime(date):
    "Convert UTC to localtime"

    ldate = date.split("T")[0]
    ltime = date.split("T")[1]

    lhour   = ltime.split(":")[0]
    lminute = ltime.split(":")[1]
    lsec    = ltime.split(":")[2]

    lyear   = ldate.split("-")[0]
    lmonth  = ldate.split("-")[1]
    lday    = ldate.split("-")[2]
    
    timetoconvert = time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(time.mktime((string.atoi(lyear),string.atoi(lmonth),string.atoi(lday),string.atoi(lhour),string.atoi(lminute),string.atoi(lsec[:-1]),0,0,-1)) - time.timezone + (time.daylight)*3600))

    return timetoconvert


def localtime_to_UTC(date):
    "Convert localtime to UTC"

    ldate = date.split(" ")[0]
    ltime = date.split(" ")[1]

    lhour   = ltime.split(":")[0]
    lminute = ltime.split(":")[1]
    lsec    = ltime.split(":")[2]

    lyear   = ldate.split("-")[0]
    lmonth  = ldate.split("-")[1]
    lday    = ldate.split("-")[2]

    timetoconvert = time.strftime("%Y-%m-%dT%H:%M:%SZ",time.gmtime(time.mktime((string.atoi(lyear),string.atoi(lmonth),string.atoi(lday),string.atoi(lhour),string.atoi(lminute),string.atoi(lsec),0,0,-1))))

    return timetoconvert

def get_creation_date(sysno):
    "Returns the creation date of the record 'sysno'."

    out   = ""
#<<<<<<< oai2d.wml
    query = "SELECT DATE_FORMAT(creation_date,'%%Y-%%m-%%d %%H:%%i:%%s') FROM bibitem WHERE id='%s'" % (sysno)
#=======
#    query = "SELECT DATE_FORMAT(creation_date,'%%Y-%%m-%%d') FROM bibrec WHERE id='%s'" % (sysno)
#>>>>>>> 1.6

    cursor.execute(query)
    row = cursor.fetchone()
    if row:
        out = row[0]
    return localtime_to_UTC(out)

def get_modification_date(sysno):
    "Returns the date of last modification for the record 'sysno'."

    out = ""

    query = "SELECT DATE_FORMAT(modification_date,'%%Y-%%m-%%d %%H:%%i:%%s') FROM bibrec WHERE id='%s'" % (sysno)

    cursor.execute(query)
    row = cursor.fetchone()
    if row:
        out = row[0]
    return localtime_to_UTC(out)

def check_date(date, time):
    "Check if the date has a correct format"

    if(re.sub("[0123456789\-:TZ]","",date) == ""):
        if len(date) == 10:
            date = date + time
        date = UTC_to_localtime(date)
    else:
        oai_error("badArgument","Bad datestamp format")

    return date

def record_exists(sysno):
    "Returns 1 if record with SYSNO 'sysno' exists.  Returns 0 otherwise."

    out = 0
    query = "SELECT id FROM bibrec WHERE id='%s'" % (sysno)
 
    cursor.execute(query)
    row = cursor.fetchone()
    if row:
        out = 1
    return out


def print_record(sysno, format='marcxml'):
    "Prints record 'sysno' formatted accoding to 'format'."

    # sanity check:
    if not record_exists(sysno):
        return

    if (format == "dc") or (format == "oai_dc"):
        format = "xd"

    # print record opening tags:
    
    print "  <record>"
    print "   <header>"
    for id in get_field(sysno,oaiidfield):
        print "    <identifier>%s</identifier>" % id
    print "    <datestamp>%s</datestamp>" % get_modification_date(sysno)
    for set in get_field(sysno,oaisetfield):
        print "    <setSpec>%s</setSpec>" % set
    print "   </header>"
    print "   <metadata>"
    

    if format == "marcxml":
        print """
    <record xmlns="http://www.loc.gov/MARC21/slim"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.loc.gov/MARC21/slim
            http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd"
            type="Bibliographic">
    <leader>00000coc  2200000uu 4500</leader>
        """
       ## MARC21 and XML formats, possibley OAI -- they are not in "bibfmt" table; so fetch all the data from "bibXXx" tables:

        if format == "marcxml":

            print "     <controlfield tag=\"001\">%d</controlfield>" % int(sysno)
        for digit1 in range(0,10):
            for digit2 in range(0,10):
                bx = "bib%d%dx" % (digit1, digit2)
                bibx = "bibrec_bib%d%dx" % (digit1, digit2)
                query = "SELECT b.tag,b.value,bb.field_number FROM %s AS b, %s AS bb "\
                        "WHERE bb.id_bibrec='%s' AND b.id=bb.id_bibxxx AND b.tag LIKE '%s%%' "\
                        "ORDER BY bb.field_number, b.tag ASC" % (bx, bibx, sysno, str(digit1)+str(digit2))
                cursor.execute(query)
                row = cursor.fetchone()
                field_number_old = -999
                field_old = ""
                while row:
                    field, value, field_number = row[0], row[1], row[2]
                    ind1, ind2 = field[3], field[4]
                    if ind1 == "_":
                        ind1 = " "
                    if ind2 == "_":
                        ind2 = " "                        
                    # print field tag
                    if field_number != field_number_old or field[:-1] != field_old[:-1]:
                        if format == "m":
                            print "<br><strong class=\"headline\">%s&nbsp;%s</strong>" % (encode_for_xml(field[0:3]), encode_for_xml(field[3:5]))
                        elif format == "marcxml":

                            fieldid = encode_for_xml(field[0:3])

                            if field_number_old != -999:
                                print """     </datafield>"""

                            print """     <datafield tag="%s" ind1="%s" ind2="%s">""" % (encode_for_xml(field[0:3]), encode_for_xml(ind1).lower(), encode_for_xml(ind2).lower())

                        field_number_old = field_number
                        field_old = field
                    # print subfield value
                    if format == "m":
                        print "<em class=\"headline\">$%s</em> %s" % (field[-1:], value)
                    elif format == "marcxml":
                        value = encode_for_xml(value)
                        print """      <subfield code="%s">%s</subfield>""" % (encode_for_xml(field[-1:]), value)
   
                    # fetch next subfield
                    row = cursor.fetchone()
                # all fields/subfields printed in this run, so close the tag:
                if (format == "marcxml") and field_number_old != -999:
                    print """     </datafield>"""
        print "    </record>"

    elif format == "xd":
        # XML Dublin Core format, possibly OAI -- select only some bibXXx fields:
        print """    
    <oaidc:dc xmlns="http://purl.org/dc/elements/1.1/" 
              xmlns:oaidc="http://www.openarchives.org/OAI/2.0/oai_dc/" 
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
              xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/oai_dc/ 
              http://www.openarchives.org/OAI/2.0/oai_dc.xsd">
        """

        for f in get_field(sysno, "041__a"):
            print "        <language>%s</language>" % f

        for f in get_field(sysno, "100__a"):
            print "        <creator>%s</creator>" % encode_for_xml(f)

        for f in get_field(sysno, "700__a"):
            print "        <creator>%s</creator>" % encode_for_xml(f)

        for f in get_field(sysno, "245__a"):
            print "        <title>%s</title>" % encode_for_xml(f)

        for f in get_field(sysno, "65017a"):
            print "        <subject>%s</subject>" % encode_for_xml(f)

        for f in get_field(sysno, "8564_u"):
            print "        <identifier>%s</identifier>" % encode_for_xml(f)
        
        for f in get_field(sysno, "520__a"):
            print "        <description>%s</description>" % encode_for_xml(f)            

        print "        <date>%s</date>" % get_creation_date(sysno)
        print "    </oaidc:dc>"

    # print record closing tags:
    
    print "   </metadata>"
    print "  </record>"


def main():
    "Main function which analyses the CGI request and invokes search corresponding to an OAI verb"

    # analyze user input:
    flen = 0
    ulen = 0
    param = cgi.FieldStorage()

    if param.has_key('verb'):

        verb = param['verb'].value
        
        if param.has_key('metadataPrefix'):
            metadataPrefix = param['metadataPrefix'].value
        else:
            metadataPrefix = ""
        if param.has_key('from'):
            fromDate = param['from'].value
            flen = len(fromDate)
            fromDate = check_date(fromDate,"T00:00:00Z")
        else:
            fromDate = ""
        if param.has_key('until'):
            untilDate = param['until'].value
            ulen = len(untilDate)
            untilDate = check_date(untilDate,"T23:59:59Z")
        else:
            untilDate = ""

        if (ulen > 0) and (flen > 0):
            if (flen <> ulen):
                oai_error("badArgument","Bad datestamp format")
           
        if param.has_key('set'):
            set = param['set'].value
        else:
            set = ""
        if param.has_key('identifier'):
            identifier = param['identifier'].value
        else:
            identifier = ""
        if param.has_key('resumptionToken'):
            #resumptionToken exclusive
            if len(param) == 2:
                resumptionToken = param['resumptionToken'].value
            else:
                oai_error("badArgument","The request includes illegal arguments")
        else:
            resumptionToken = ""

        if verb == "Identify":
            if len(param) == 1:
                OAIIdentify()
            else:
                oai_error("badArgument","The request includes illegal arguments")
        elif verb == "ListMetadataFormats":
            OAIListMetadataFormats(identifier,resumptionToken)
        elif verb == "ListRecords":
            if metadataPrefix=='oai_dc' or metadataPrefix=='marcxml' or resumptionToken:
                OAIListRecords(fromDate,untilDate,set,metadataPrefix,resumptionToken)
            else:
                if metadataPrefix == "":
                    oai_error("badArgument","metadataPrefix missing")
                else:
                    oai_error("cannotDisseminateFormat","invalid metadataPrefix")

        elif verb == "ListIdentifiers":
            if metadataPrefix=='oai_dc' or metadataPrefix=='marcxml' or resumptionToken:
                OAIListIdentifiers(fromDate,untilDate,set,resumptionToken)
            else:
                if metadataPrefix == "":
                    oai_error("badArgument","metadataPrefix missing")
                else:
                    oai_error("cannotDisseminateFormat","invalid metadataPrefix")
        elif verb == "GetRecord":
            if identifier:
                if metadataPrefix=='oai_dc' or metadataPrefix=='marcxml':
                    OAIGetRecord(identifier, metadataPrefix)
                else:
                    if metadataPrefix == "":
                        oai_error("badArgument","metadataPrefix missing")
                    else:
                        oai_error("cannotDisseminateFormat","invalid metadataPrefix")
            else:
                oai_error("badArgument","Record Identifier Missing")
        elif verb == "ListSets":
            if (((len(param)) > 2 ) or ((len(param) == 2) and (resumptionToken == ""))):
                oai_error("badArgument","The request includes illegal arguments")
            OAIListSets(resumptionToken)
        else:
            oai_error("badVerb","Illegal OAI verb")
    else:
        oai_error("badVerb","Illegal OAI verb")


def OAIListMetadataFormats(identifier,resumptionToken):
    "Generates response to OAIListMetadataFormats verb."

    flag = 1 # list or not depending on identifier

    if identifier:

        flag = 0

        sysno = OAIGetSysno(identifier)

        if record_exists(sysno):

            flag = 1

        else:
            oai_error("badArgument","invalid record Identifier")
            
    print_oai_header("ListMetadataFormats")

    if flag:
        print """
   <metadataFormat>
    <metadataPrefix>oai_dc</metadataPrefix>
    <schema>http://www.openarchives.org/OAI/1.1/dc.xsd</schema>
    <metadataNamespace>http://purl.org/dc/elements/1.1/</metadataNamespace>
   </metadataFormat>
   <metadataFormat>
    <metadataPrefix>marcxml</metadataPrefix>
    <schema>http://www.loc.gov/standards/marcxml/schema/MARC21slim.xsd</schema>
    <metadataNamespace>http://www.loc.gov/MARC21/slim</metadataNamespace>
   </metadataFormat>
        """
    print_oai_footer("ListMetadataFormats")


def OAIListRecords(fromDate,untilDate,set,metadataPrefix,resumptionToken):
    "Generates response to OAIListRecords verb."

    sysnos = []
    sysno = []

    # check if the resumptionToken did not expire
    if resumptionToken:
        filename = "%s/RTdata/%s" % (runtimelogdir, resumptionToken)
        if os.path.exists(filename) == 0:
             oai_error("badResumptionToken","ResumptionToken expired")

    if resumptionToken:
        sysnos = OAICacheOut(resumptionToken)
        metadataPrefix = sysnos.pop()
    else:
        sysnos = OAIGetSysnoList(set, fromDate, untilDate)

    if len(sysnos) == 0: # noRecordsMatch error
        oai_error("noRecordsMatch","no records correspond to the request")

    print_oai_header("ListRecords")

    i = 0
    for s in sysnos:
        if s:
            i = i + 1
            if i > nb_records_in_resume:           # cache or write?
                if i ==  nb_records_in_resume + 1: # resumptionToken?
                    resumptionToken = OAIGenResumptionToken()
                    extdate = OAIGetResponseDate(oai_rt_expire)
                    if extdate:
                        print """<resumptionToken expirationDate="%s">%s</resumptionToken>""" % (extdate,resumptionToken)
                    else:
                        print "<resumptionToken>%s</resumptionToken>" % resumptionToken
                sysno.append(s)
            else:
                done = 0
                for f in get_field(s, "245__a"):
                    if done == 0:
                        print_record(s, metadataPrefix)

    print_oai_footer("ListRecords")

    if i > nb_records_in_resume:
        OAICacheClean()
        sysno.append(metadataPrefix)
        OAICacheIn(resumptionToken,sysno)

def OAIListSets(resumptionToken):
    "Lists available sets for OAI metadata harvesting."

    # note: no flow control in ListSets
    
    print_oai_header("ListSets")

    sets = get_sets()

    for s in sets:

        print "   <set>"
        print "    <setSpec>%s</setSpec>" % s[0]
        print "    <setName>%s</setName>" % s[1]
        if s[2]:
            print "    <setDescription>%s</setDescription>" % s[2]
        print "   </set>"

    print_oai_footer("ListSets")
    
def OAIGetRecord(identifier, metadataPrefix):
    """Returns record 'identifier' according to 'metadataPrefix' format for OAI metadata harvesting."""
    
    sysno = OAIGetSysno(identifier)

    if record_exists(sysno):        
        datestamp = get_modification_date(sysno)
    else:
        oai_error("badArgument","invalid record Identifier")

    print_oai_header("GetRecord")
    print_record(sysno, metadataPrefix)
    print_oai_footer("GetRecord")

def OAIListIdentifiers(fromDate,untilDate,set,resumptionToken):
    "Prints OAI response to the ListIdentifiers verb."

    sysno = []
    sysnos = []

    if resumptionToken:
        filename = "%s/RTdata/%s" % (runtimelogdir, resumptionToken)
        if os.path.exists(filename) == 0:
             oai_error("badResumptionToken","ResumptionToken expired")

    if resumptionToken:
        sysnos = OAICacheOut(resumptionToken)
    else:
        sysnos = OAIGetSysnoList(set, fromDate, untilDate)

    if len(sysnos) == 0: # noRecordsMatch error
        oai_error("noRecordsMatch","no records correspond to the request")

    print_oai_header("ListIdentifiers")

    i = 0
    for s in sysnos:
        if s:
            i = i + 1
            if i > nb_identifiers_in_resume:           # cache or write?
                if i ==  nb_identifiers_in_resume + 1: # resumptionToken?
                    resumptionToken = OAIGenResumptionToken()
                    extdate = OAIGetResponseDate(oai_rt_expire)
                    if extdate:
                        print """  <resumptionToken expirationDate="%s">%s</resumptionToken>""" % (extdate,resumptionToken)
                    else:
                        print "  <resumptionToken>%s</resumptionToken>" % resumptionToken
                sysno.append(s)
            else:
                done = 0
                for f in get_field(s, "245__a"):
                    if done == 0:
                        for id in get_field(s,oaiidfield):
                            print "    <header>"
                            print "      <identifier>%s</identifier>" % id
                            print "      <datestamp>%s</datestamp>" % get_modification_date(OAIGetSysno(id))
                            for set in get_field(s,oaisetfield):
                                print "      <setSpec>%s</setSpec>" % set
                            print "    </header>"
                        done = 1
                    
    if i > nb_identifiers_in_resume:
        OAICacheClean() # clean cache from expired resumptionTokens
        OAICacheIn(resumptionToken,sysno)

    print_oai_footer("ListIdentifiers")


def OAIIdentify():
    "Generates response to OAIIdentify verb."
        
    responseDate          = OAIGetResponseDate()
    requestURL            = OAIGetRequestURL()
    repositoryName        = cdsname
    baseURL               = "%soai2d" % cgibinurl
    protocolVersion       = "2.0"
    adminEmail            = "mailto:%s" % supportemail
    repositoryIdentifier  = "%s" % oaiidprefix
    sampleIdentifier      = oaisampleidentifier
    identifyDescription   = oaiidentifydescription

    print_oai_header("Identify")

    print "    <repositoryName>" + repositoryName + "</repositoryName>"
    print "    <baseURL>" + baseURL + "</baseURL>"
    print "    <protocolVersion>" + protocolVersion + "</protocolVersion>"
    print "    <adminEmail>" + adminEmail + "</adminEmail>"
    print "    <earliestDatestamp>%s</earliestDatestamp>" % get_earliest_datestamp()
    print "    <deletedRecord>no</deletedRecord>"
    print "    <granularity>YYYY-MM-DDThh:mm:ssZ</granularity>"
    #    print "    <compression></compression>"
    print oaiidentifydescription

    print_oai_footer("Identify")
    
def OAIGetRequestURL():
    "Generates requestURL tag for OAI."

    if os.environ.has_key('SERVER_NAME'):
        server_name = os.environ['SERVER_NAME']
    else:
        server_name = ""
    if os.environ.has_key('QUERY_STRING'):
        query_string = os.environ['QUERY_STRING']
    else:
        query_string = ""
    if os.environ.has_key('SCRIPT_NAME'):
        script_name = os.environ['SCRIPT_NAME']
    else:
        script_name = ""

    requestURL = "http://" + server_name + script_name 
    if query_string:
        requestURL = requestURL + "?"  + re_amp.sub("&amp;", query_string)

    return requestURL

def OAIGetResponseDate(delay=0):
    "Generates responseDate tag for OAI."
    
    return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(time.time() + delay))


def oai_error(code, msg):
    "OAI error occured"

    print_oai_header("")
    print """ <error code="%s">%s</error>""" % (code, msg)
    print_oai_footer("")
    sys.exit()


def OAIGetSysno(identifier):
    "Returns the first MySQL BIB ID for the OAI identifier 'identifier', if it exists."
    sysno = None
    if identifier:
        query = "SELECT DISTINCT(bb.id_bibrec) FROM bib90x AS bx, bibrec_bib90x AS bb WHERE bx.tag='%s' AND bb.id_bibxxx=bx.id AND bx.value='%s'" % (oaiidfield,identifier)
        cursor.execute(query)
        row = cursor.fetchone()
        if row:
            sysno = row[0]
        
    return sysno

def OAIGetSysnoList(set, date_from, date_until):
    "Returns list of system numbers for the OAI set 'set', modified from 'date_from' until 'date_until'."

    out_dict = {} # dict to hold list of out sysnos as its keys

    if set:
        query = "SELECT DISTINCT bibx.id_bibrec FROM bib90x AS bx LEFT JOIN bibrec_bib90x AS bibx ON bx.id=bibx.id_bibxxx LEFT JOIN bibrec AS b ON b.id=bibx.id_bibrec WHERE bx.tag='%s' AND bx.value='%s'" % (oaisetfield,set)
    else:
        query = "SELECT DISTINCT bibx.id_bibrec FROM bib90x AS bx LEFT JOIN bibrec_bib90x AS bibx ON bx.id=bibx.id_bibxxx LEFT JOIN bibrec AS b ON b.id=bibx.id_bibrec WHERE bx.tag='%s'" % (oaiidfield)

    if date_until:
        query = query + " AND b.modification_date <= '%s'" % date_until
    if date_from:
        query = query + " AND b.modification_date >= '%s'" % date_from

    cursor.execute(query)
    row = cursor.fetchone()
    while row:
        out_dict[row[0]] = 1
        row = cursor.fetchone()

    return out_dict.keys()


def OAIGenResumptionToken():
    "Generates unique ID for resumption token management."

    return md5.new(str(time.time())).hexdigest()


def OAICacheIn(resumptionToken, sysnos):
    "Stores or adds sysnos in cache.  Input is a string of sysnos separated by commas."

    filename = "%s/RTdata/%s" % (runtimelogdir, resumptionToken)

    fil = open(filename,"w")
    cPickle.dump(sysnos,fil)
    fil.close()
    return 1


def OAICacheOut(resumptionToken):
    "Restores string of comma-separated system numbers from cache."
    
    sysnos = []

    filename = "%s/RTdata/%s" % (runtimelogdir, resumptionToken)

    if OAICacheStatus(resumptionToken):
        fil = open(filename,"r")
        sysnos = cPickle.load(fil)
        fil.close()
    else:
        return 0
    return sysnos

def OAICacheClean():
    "Removes cached resumptionTokens older than specified"
    
    directory = "%s/RTdata" % runtimelogdir

    files = os.listdir(directory)

    for f in files:
        filename = directory + "/" + f
        # cache entry expires when not modified during a specified period of time
        if ((time.time() - os.path.getmtime(filename)) > oai_rt_expire):
            os.remove(filename)

    return 1

def OAICacheStatus(resumptionToken):
    "Checks cache status.  Returns 0 for empty, 1 for full."
    
    filename = "%s/RTdata/%s" % (runtimelogdir, resumptionToken)
    
    if os.path.exists(filename):
        if os.path.getsize(filename) > 0:
            return 1
        else:
            return 0
    else:
        return 0

def get_earliest_datestamp():
    "Returns earliest datestamp"

    out = ""

    cursor_bis = db.cursor()

    query_bis = "SELECT MIN(creation_date) FROM bibrec"

    cursor_bis.execute(query_bis)
    row_bis = cursor_bis.fetchone()
  
    out = row_bis[0][:10] + " 00:00:00"
 
    cursor_bis.close()

    return localtime_to_UTC(out)

def get_sets():
    "Returns list of sets."

    out = []
    row = ['','']

    cursor_bis = db.cursor()
    
    query_bis = "SELECT setSpec,setName,setDescription FROM oaiset"
    cursor_bis.execute(query_bis)
    row_bis = cursor_bis.fetchone()    
    while row_bis:
        row = [row_bis[0],row_bis[1],row_bis[2]]
        out.append(row)
        row_bis = cursor_bis.fetchone()
 
    cursor_bis.close()
            
    return out

### okay, here we go:
if __name__ == '__main__':
    main()

</protect>
