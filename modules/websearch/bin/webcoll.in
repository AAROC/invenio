#!@PYTHON@
## -*- mode: python; coding: utf-8; -*-
##
## $Id$
##
## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002, 2003, 2004, 2005 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.  
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

__version__ = "$Id$"

## import modules:
try:
    import calendar
    import copy
    import getopt
    import getpass
    import marshal
    import signal
    import sys
    import cgi
    import sre
    import os
    import math
    import string
    import urllib
    import zlib
    import MySQLdb
    import Numeric
    import time
    import traceback
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

try:
    pylibdir = "@prefix@/lib/python"
    sys.path.append('%s' % pylibdir)
    from cdsware.config import *
    from cdsware.messages import *
    from cdsware.search_engine import HitSet, search_pattern, get_creation_date, nice_number, get_field_i18nname
    from cdsware.search_engine_config import cfg_author_et_al_threshold, cfg_instant_browse, cfg_max_recID, cfg_narrow_search_show_grandsons
    from cdsware.dbquery import run_sql    
    from cdsware.access_control_engine import acc_authorize_action
    from cdsware.bibrank_record_sorter import get_bibrank_methods
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

## global vars
collection_house = {} # will hold collections we treat in this run of the program; a dict of {collname2, collobject1}, ...
options = {} # will hold task options

# cfg_cache_last_updated_timestamp_tolerance -- cache timestamp
# tolerance (in seconds), to account for the fact that an admin might
# accidentally happen to edit the collection definitions at exactly
# the same second when some webcoll process was about to be started.
# In order to be safe, let's put an exaggerated timestamp tolerance
# value such as 20 seconds:
cfg_cache_last_updated_timestamp_tolerance = 20

# cfg_cache_last_updated_timestamp_file -- location of the cache
# timestamp file:
cfg_cache_last_updated_timestamp_file = "%s/collections/last_updated" % cachedir

def get_collection(colname):
    """Return collection object from the collection house for given colname.
       If does not exist, then create it."""
    if not collection_house.has_key(colname):
        colobject = Collection(colname)
        collection_house[colname] = colobject
    return collection_house[colname]

## auxiliary functions:
def mymkdir(newdir, mode=0777):
    """works the way a good mkdir should :)
        - already exists, silently complete
        - regular file in the way, raise an exception
        - parent directory(ies) does not exist, make them as well
    """
    if os.path.isdir(newdir):
        pass
    elif os.path.isfile(newdir):
        raise OSError("a file with the same name as the desired " \
                      "dir, '%s', already exists." % newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            mymkdir(head, mode)
        if tail:
	    os.umask(022)
            os.mkdir(newdir, mode)

def escape_string(s):
    "Escapes special chars in string.  For MySQL queries."
    s = MySQLdb.escape_string(s)
    return s

def is_selected(var, fld):
    "Checks if the two are equal, and if yes, returns ' selected'.  Useful for select boxes."
    if var == fld:
        return " selected"
    else:
        return ""

def write_message(msg, stream=sys.stdout):
    """Write message and flush output stream (may be sys.stdout or sys.stderr).  Useful for debugging stuff."""
    if stream == sys.stdout or stream == sys.stderr:
        stream.write(time.strftime("%Y-%m-%d %H:%M:%S --> ", time.localtime()))
        stream.write("%s\n" % msg)
        stream.flush()
    else:
        sys.stderr.write("Unknown stream %s.  [must be sys.stdout or sys.stderr]\n" % stream)
    return

def create_andornot_box(name='op', value='', ln='en'):
    "Returns HTML code for the AND/OR/NOT selection box."
    out = """
    <select name="%s">
    <option value="a"%s>%s
    <option value="o"%s>%s
    <option value="n"%s>%s
    </select>
    """ % (name,
           is_selected('a', value), msg_and[ln],
           is_selected('o', value), msg_or[ln],
           is_selected('n', value), msg_and_not[ln])
    return out

def create_matchtype_box(name='m', value='', ln='en'):
    "Returns HTML code for the 'match type' selection box."
    out = """
    <select name="%s">
    <option value="a"%s>%s
    <option value="o"%s>%s
    <option value="e"%s>%s
    <option value="p"%s>%s
    <option value="r"%s>%s
    </select>
    """ % (name,
           is_selected('a', value), msg_all_of_the_words[ln],
           is_selected('o', value), msg_any_of_the_words[ln],
           is_selected('e', value), msg_exact_phrase[ln],
           is_selected('p', value), msg_partial_phrase[ln],
           is_selected('r', value), msg_regular_expression[ln])
    return out

def get_field(recID, tag):
    "Gets list of field 'tag' for the record with 'recID' system number."

    out = []
    digit = tag[0:2]

    bx = "bib%sx" % digit
    bibx = "bibrec_bib%sx" % digit
    query = "SELECT bx.value FROM %s AS bx, %s AS bibx WHERE bibx.id_bibrec='%s' AND bx.id=bibx.id_bibxxx AND bx.tag='%s'" \
            % (bx, bibx, recID, tag)
    res = run_sql(query)
    for row in res:        
        out.append(row[0])
    return out

def print_record(recID, format='hb', ln=cdslang):
    "Prints record 'recID' formatted accoding to 'format'."

    out = ""
    # HTML brief format by default
    query = "SELECT value FROM bibfmt WHERE id_bibrec='%s' AND format='%s'" % (recID, format)
    res = run_sql(query, None, 1)
    if res:
        # record 'recID' is formatted in 'format', so print it
        out += "%s" % zlib.decompress(res[0][0])
    else:
        # record 'recID' does not exist in format 'format', so print some default format:
        # firstly, title:
        titles = get_field(recID, "245__a")
        for title in titles:
            out += "<strong>%s</strong> " % cgi.escape(title)
        # secondly, authors:
        authors = get_field(recID, "100__a") + get_field(recID, "700__a")
        if authors:
            out += " / "
            for i in range (0,cfg_author_et_al_threshold):
                if i < len(authors):
                    out += """<a href="%s/search.py?p=%s&f=author">%s</a> ;""" \
                           % (weburl, urllib.quote(authors[i]), cgi.escape(authors[i]))
            if len(authors) > cfg_author_et_al_threshold:
                out += " <em>et al.</em>"
        # thirdly, date of creation:
        dates = get_field(recID, "260__c")
        for date in dates:
            out += " %s." % cgi.escape(date)
        # thirdly bis, report numbers:
        rns = get_field(recID, "037__a")
        for rn in rns:
            out += """ <small class="quicknote">[%s]</small>""" % cgi.escape(rn)
        rns = get_field(recID, "088__a")
        for rn in rns:
            out += """ <small class="quicknote">[%s]</small>""" % cgi.escape(rn)
        # fourthly, beginning of abstract:
        abstracts = get_field(recID, "520__a")
        for abstract in abstracts:
            out += "<br><small>%s [...]</small>" % cgi.escape(abstract[:1+string.find(abstract, '.')])
        # fifthly, fulltext link:
        urls_z = get_field(recID, "8564_z")
        urls_u = get_field(recID, "8564_u")
        for idx in range(0,len(urls_u)):
            out += """<br><small class="note"><a class="note" href="%s">%s</a></small>""" % (urls_u[idx], urls_u[idx])

    # at the end of HTML mode, print "Detailed record" and "Mark record" functions:
    out +=  """<br><span class="moreinfo"><a class="moreinfo" href="%s/search.py?recid=%s&amp;ln=%s">%s</a>""" \
           % (weburl, recID, ln, msg_detailed_record[ln])
    out += """<span class="moreinfo"> - <a class="moreinfo" href="%s/search.py?p=recid:%d&amp;rm=wrd&amp;ln=%s">%s</a></span>\n""" % \
           (weburl, recID, ln, msg_similar_records[ln])
    #out += """<- <input name="mark[]" type="checkbox" value="%s"> Mark record""" % recID
    out += "</span>"
    return out

class Collection:
    "Holds the information on collections (id,name,dbquery)."

    def __init__(self, name=""):
        "Creates collection instance by querying the MySQL configuration database about 'name'."
        self.calculate_reclist_run_already = 0 # to speed things up wihtout much refactoring
        self.update_reclist_run_already = 0 # to speed things up wihtout much refactoring
        self.reclist_with_nonpublic_subcolls = HitSet()
        if not name:
            self.name = cdsname # by default we are working on the home page
            self.id = 1
            self.dbquery = None
            self.nbrecs = None
            self.reclist = HitSet()
        else:
            self.name = name
            query = "SELECT id,name,dbquery,nbrecs,reclist FROM collection WHERE name='%s'" % escape_string(name)
            try:
                res = run_sql(query, None, 1)
                if res:
                    self.id = res[0][0]
                    self.name = res[0][1]
                    self.dbquery = res[0][2]
                    self.nbrecs = res[0][3]
                    try:
                        self.reclist = HitSet(Numeric.loads(zlib.decompress(res[0][5])))
                    except:
                        self.reclist = HitSet()
                else: # collection does not exist!
                    self.id = None
                    self.dbquery = None
                    self.nbrecs = None
                    self.reclist = HitSet()
            except MySQLdb.Error, e:
                print "Error %d: %s" % (e.args[0], e.args[1])
                sys.exit(1)

    def get_name(self, ln=cdslang, name_type="ln", prolog="", epilog="", prolog_suffix=" ", epilog_suffix=""):
        """Return nicely formatted collection name for language LN.
        The NAME_TYPE may be 'ln' (=long name), 'sn' (=short name), etc."""        
        out = prolog
        i18name = ""
        res = run_sql("SELECT value FROM collectionname WHERE id_collection=%s AND ln=%s AND type=%s", (self.id, ln, name_type))
        try:
            i18name += res[0][0]
        except IndexError:
            pass
        if i18name:
            out += i18name
        else:
            out += self.name
        out += epilog
        return out

    def get_ancestors(self):
        "Returns list of ancestors of the current collection."
        ancestors = []
        id_son = self.id
        while 1:
            query = "SELECT cc.id_dad,c.name FROM collection_collection AS cc, collection AS c "\
                    "WHERE cc.id_son=%d AND c.id=cc.id_dad" % int(id_son)
            res = run_sql(query, None, 1)
            if res:
                col_ancestor = get_collection(res[0][1])
                ancestors.append(col_ancestor)
                id_son = res[0][0]
            else:
                break
        ancestors.reverse()
        return ancestors

    def restricted_p(self):
        """Predicate to test if the collection is restricted or not.  Return the contect of the
         `restrited' column of the collection table (typically Apache group).  Otherwise return
         None if the collection is public."""
        out = None
        query = "SELECT restricted FROM collection WHERE id=%d" % self.id
        res = run_sql(query, None, 1)        
        try:
            out = res[0][0]
        except:
            pass        
        return out

    def get_sons(self, type='r'):
        "Returns list of direct sons of type 'type' for the current collection."
        sons = []
        id_dad = self.id
        query = "SELECT cc.id_son,c.name FROM collection_collection AS cc, collection AS c "\
                "WHERE cc.id_dad=%d AND cc.type='%s' AND c.id=cc.id_son ORDER BY score DESC, c.name ASC" % (int(id_dad), type)
        res = run_sql(query)
        for row in res:
            sons.append(get_collection(row[1]))
        return sons

    def get_descendants(self, type='r'):
        "Returns list of all descendants of type 'type' for the current collection."
        descendants = []
        id_dad = self.id
        query = "SELECT cc.id_son,c.name FROM collection_collection AS cc, collection AS c "\
                "WHERE cc.id_dad=%d AND cc.type='%s' AND c.id=cc.id_son ORDER BY score DESC" % (int(id_dad), type)
        res = run_sql(query)
        for row in res:
            col_desc = get_collection(row[1])
            descendants.append(col_desc)
            descendants += col_desc.get_descendants()
        return descendants

    def write_cache_file(self, filename='', filebody=''):
        "Write a file inside collection cache."
        # open file:
        dirname = "%s/collections/%d" % (cachedir, self.id) 
        mymkdir(dirname)
        fullfilename = dirname + "/%s.html" % filename
        try:
	    os.umask(022)
            f = open(fullfilename, "w")
        except IOError, v:
            try:
                (code, message) = v
            except:
                code = 0
                message = v
            print "I/O Error: " + str(message) + " (" + str(code) + ")"
            sys.exit(1)
        # print user info:
        if options["verbose"] >= 6:
            write_message("... creating %s" % fullfilename)
        sys.stdout.flush()
        # print page body:
        f.write(filebody)
        # close file:
        f.close()
        
    def update_webpage_cache(self):
        """Create collection page header, navtrail, body (including left and right stripes) and footer, and 
           call write_cache_file() afterwards to update the collection webpage cache."""
        ## do this for each language:
        for lang, lang_fullname in language_list_long():
            ## first, update navtrail:
            for as in range(0,2):
                self.write_cache_file("navtrail-as=%s-ln=%s" % (as, lang), self.create_navtrail_links(as, lang))
            ## second, update page body:
            for as in range(0,2): # do both simple search and advanced search pages:
                body = ""
                body += """<form action="%s/search.py" method="get">""" % weburl
                body += "" + self.create_searchfor(as, lang)
                body += self.create_portalbox(lang, 'np')
                body += """<table cellspacing="0" cellpadding="0" border="0">"""
                body += """<tr>"""
                body += """<td valign="top">""" + self.create_narrowsearch(as, lang, msg_narrow_search[lang]) + "</td>"
                body_focuson = self.create_narrowsearch(as, lang, msg_focus_on[lang], "v")
                if body_focuson:
                    body += """<td valign="top">""" + body_focuson + """</td>"""
                body += "</tr></table>"
                body += self.create_portalbox(lang, 'ne')
                body += "</form>"
                self.write_cache_file("body-as=%s-ln=%s" % (as, lang), body)
            ## third, write portalboxes:
            self.write_cache_file("portalbox-tp-ln=%s" % lang, self.create_portalbox(lang, "tp"))
            self.write_cache_file("portalbox-te-ln=%s" % lang, self.create_portalbox(lang, "te"))
            self.write_cache_file("portalbox-lt-ln=%s" % lang, self.create_portalbox(lang, "lt"))
            self.write_cache_file("portalbox-rt-ln=%s" % lang, self.create_portalbox(lang, "rt"))
            ## fourth, write 'last updated' information:
            self.write_cache_file("last-updated-ln=%s" % lang, time.strftime("%02d %b %04Y %02H:%02M:%02S %Z", time.localtime()))
        return

    def create_navtrail_links(self, \
                              as=0,
                              ln=cdslang,
                              separator=" &gt; "):
        """Creates navigation trail links, i.e. links to collection ancestors (except Home collection).
        If as==1, then links to Advanced Search interfaces; otherwise Simple Search.        
        """
        out = ""
        for dad in self.get_ancestors():
            if dad.name != cdsname: # exclude Home collection
                if out:
                    out += separator
                out += """<a class="navtrail" href="%s/?c=%s&amp;as=%d&amp;ln=%s">%s</a>""" % \
                            (weburl, urllib.quote_plus(dad.name), as, ln, dad.get_name(ln))
        return out

    def create_nbrecs_info(self, ln=cdslang, prolog="""&nbsp;<small class="nbdoccoll">(""", epilog=""")</small>"""):
        "Return information on the number of records."
        out = ""
        if self.nbrecs:
            out = prolog + nice_number(self.nbrecs, ln) + epilog
        return out

    def create_portalbox(self, lang=cdslang, position="rt"):
        """Creates portalboxes of language CDSLANG of the position POSITION by consulting MySQL configuration database.
           The position may be: 'lt'='left top', 'rt'='right top', etc."""
        out = ""
        query = "SELECT p.title,p.body FROM portalbox AS p, collection_portalbox AS cp "\
                " WHERE cp.id_collection=%d AND p.id=cp.id_portalbox AND cp.ln='%s' AND cp.position='%s' "\
                " ORDER BY cp.score DESC" % (self.id, lang, position)
        res = run_sql(query)
        for row in res:
            title, body = row[0], row[1]
            if title:
                out += """<div class="portalbox">        
                             <div class="portalboxheader">%s</div>
                             <div class="portalboxbody">%s</div>
                          </div>""" % (title, body)
            else:
                # no title specified, so print body ``as is'' only:
                out += body
        return out

    def create_narrowsearch(self, as=0, ln=cdslang, title="Narrow search", type="r"):
        """Creates list of collection descendants of type 'type' under title 'title'.
        If as==1, then links to Advanced Search interfaces; otherwise Simple Search.        
        Suitable for 'Narrow search' and 'Focus on' boxes."""        
        narrowsearch=""
        # return nothing for type 'v' (virtual collection) if there are no sons:
        if type == 'v' and not self.get_sons(type):
            return ""
        # firstly write silent 'cc' (=current collection) argument:
        if type == 'r': # but not for virtual collections
            narrowsearch += """<input type="hidden" name="cc" value="%s">""" % self.name
        # then get list of sons and analyse it:
        sons = self.get_sons(type)
        # decide upon writing style: if there are grandchildren, then print in bold        
        descendants = self.get_descendants(type)
        if len(descendants)>len(sons):
            style_prolog = "<strong>"
            style_epilog = "</strong>"
        else:
            style_prolog = ""
            style_epilog = ""
        # are there some sons?
        if len(sons):
            narrowsearch += """<table class="narrowsearchbox">
                                <thead>
                                 <tr>
                                  <th colspan="2" align="left" class="narrowsearchboxheader">
                                    %s
                                  </th>
                                 </tr>
                                </thead>
                                <tbody>""" % title
            # iterate through sons:
            for son in sons:
                narrowsearch += """<tr><td class="narrowsearchboxbody" valign="top">"""
                if type=='r':
                    if son.restricted_p() and son.restricted_p() != self.restricted_p():
                        narrowsearch += """<input type=checkbox name="c" value="%s">&nbsp;</td>""" % son.name
                    else:
                        narrowsearch += """<input type=checkbox name="c" value="%s" checked>&nbsp;</td>""" % son.name
                narrowsearch += """<td valign="top"><a href="%s/?c=%s&amp;as=%d&amp;ln=%s">%s%s%s</a>%s """ % \
                                (weburl, urllib.quote_plus(son.name), as, ln, style_prolog, son.get_name(ln), style_epilog, son.create_nbrecs_info(ln))
                if son.restricted_p():
                    narrowsearch += """ <small class="warning">[%s]</small>""" % msg_restricted[ln]
                if cfg_narrow_search_show_grandsons:
                    # iterate trough grandsons:
                    grandsons = son.get_sons()
                    nb_grandsons = len(grandsons)
                    if nb_grandsons:
                        narrowsearch += """<br>"""
                        for i in range(0,nb_grandsons):
                            narrowsearch += """<a href="%s/?c=%s&amp;as=%d&amp;ln=%s">%s</a>%s """ % \
                                            (weburl, urllib.quote_plus(grandsons[i].name), as, ln, grandsons[i].get_name(ln), \
                                             grandsons[i].create_nbrecs_info(ln))
                narrowsearch += """</td></tr>"""
            narrowsearch += "</tbody></table>"            
        else:
            if type == 'r':
                # no sons, and type 'r', so print info on collection content:
                narrowsearch += """<table class="narrowsearchbox">
                                    <thead>
                                     <tr>
                                      <th class="narrowsearchboxheader">
                                        %s
                                      </th>
                                     </tr>
                                    </thead>
                                    <tbody>
                                     <tr>
                                      <td class="narrowsearchboxbody">%s</td>
                                     </tr>
                                    <tbody>
                                   </table>""" % (msg_latest_additions[ln], self.create_instant_browse(ln=ln))

        return narrowsearch

    def create_instant_browse(self, rg=cfg_instant_browse, ln=cdslang):
        "Searches database and produces list of last 'rg' records."
        box = ""
        if self.restricted_p():
            box += msg_collection_restricted_content[ln]
        else:
            url = "%s/search.py?cc=%s&jrec=%d" % (weburl, urllib.quote_plus(self.name), rg+1)
            if self.nbrecs and self.reclist:
                # firstly, get last 'rg' records:
                box += """<table class="latestadditionsbox">"""
                recIDs = Numeric.nonzero(self.reclist._set)
                for idx in range(self.nbrecs-1, self.nbrecs-rg-1, -1):
                    if idx>=0:
                        box += """<tr>
                                    <td class="latestadditionsboxtimebody">%s</td>
                                    <td class="latestadditionsboxrecordbody">%s</td>
                                  </tr>""" % (get_creation_date(recIDs[idx],fmt="%Y-%m-%d<br>%H:%i"), print_record(recIDs[idx], ln=ln))
                box += "</table>"
                if self.nbrecs > rg:
                    box += """<div align="right"><small><a href="%s&amp;ln=%s">[&gt;&gt; %s]</a></small></div>""" % (url, ln, msg_more[ln])
            else:
                box += msg_collection_contains_no_records[ln]
        return box

    def create_searchoptions(self):
        "Produces 'Search options' portal box."
        box=""
        query = """SELECT DISTINCT(cff.id_field),f.code,f.name FROM collection_field_fieldvalue AS cff, field AS f
                   WHERE cff.id_collection=%d AND cff.id_fieldvalue IS NOT NULL AND cff.id_field=f.id
                   ORDER BY cff.score DESC""" % self.id
        res = run_sql(query)
        if res:
            for row in res:
                field_id = row[0]
                field_code = row[1]
                field_name = row[2]                
                query_bis = """SELECT fv.value,fv.name FROM fieldvalue AS fv, collection_field_fieldvalue AS cff
                               WHERE cff.id_collection=%d AND cff.type='seo' AND cff.id_field=%d AND fv.id=cff.id_fieldvalue
                               ORDER BY cff.score_fieldvalue DESC, cff.score DESC, fv.name ASC""" % (self.id, field_id)
                res_bis = run_sql(query_bis)                
                if res_bis:
                    box += """<select name="%s">""" % field_code
                    box += """<option value="">any %s""" % field_name
                    for row_bis in res_bis:
                        box += """<option value="%s">%s""" % (cgi.escape(row_bis[0], 1), row_bis[1])
                    box += """</select>"""
        return box

    def create_inputdate(self, name="d1", ln=cdslang):
        "Produces 'From Date', 'Until Date' kind of selection box.  Suitable for search options."
        box = ""
        # day
        box += """<select name="%sd">""" % name
        box += """<option value="">%s""" % msg_any_day[ln]
        for day in range(1,32):
            box += """<option value="%02d">%02d""" % (day, day)
        box += """</select>"""
        # month
        box += """<select name="%sm">""" % name
        box += """<option value="">%s""" % msg_any_month[ln]
        for mm, month in [(1,msg_january[ln]), (2,msg_february[ln]), (3,msg_march[ln]), (4,msg_april[ln]), \
                          (5,msg_may[ln]), (6,msg_june[ln]), (7,msg_july[ln]), (8,msg_august[ln]), \
                          (9,msg_september[ln]), (10,msg_october[ln]), (11,msg_november[ln]), (12,msg_december[ln])]:
            box += """<option value="%02d">%s""" % (mm, month)
        box += """</select>"""
        # year
        box += """<select name="%sy">""" % name
        box += """<option value="">%s""" % msg_any_year[ln]
        this_year = int(time.strftime("%Y", time.localtime()))       
        for year in range(this_year-20, this_year+1):
            box += """<option value="%d">%d""" % (year, year)
        box += """</select>"""        
        return box

    def create_publishedin(self, title="From date", name="d1"):
        """Produces 'Published in' selection box, if collection name contains the text 'Articles'.
        Suitable for advanced search option."""
        out = ""
        if string.find(self.name, "Article") == -1:
            return out
        # journal title:
        cell_1a = "<small><strong>Published in:</strong></small><br>"
        cell_1a += """<select name="pt">"""
        cell_1a += """<option value="Phys. Rev. A">Phys. Rev. A"""
        cell_1a += """<option value="Phys. Rev. B">Phys. Rev. B"""
        cell_1a += """<option value="Phys. Rev. C">Phys. Rev. C"""
        cell_1a += """<option value="Phys. Rev. D">Phys. Rev. D"""
        cell_1a += """<option value="Phys. Rev. E">Phys. Rev. E"""
        cell_1a += """</select>"""
        # volume:
        cell_1b = "<small><strong>Volume:</strong></small><br>"
        cell_1b += """<input type="text" name="pv" size="4" value="">"""
        # year:
        cell_1c = "<small><strong>Year:</strong></small><br>"
        cell_1c += """<input type="text" name="py" size="4" value="">"""
        # page:
        cell_1d = "<small><strong>Page:</strong></small><br>"
        cell_1d += """<input type="text" name="pp" size="4" value="">"""
        out += """<table cellpadding="3" cellspacing="0">
                    <tr>
                      <td colspan="3" height="3">
                      </td>
                    </tr>
                    <tr valign="bottom" class="searchbox">
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                    </tr>
                   </table>""" % \
              (cell_1a, cell_1b, cell_1c, cell_1d)
        return out

    def create_sortoptions(self, ln=cdslang):
        "Produces 'Sort options' portal box."
        box=""
        query = """SELECT f.code,f.name FROM field AS f, collection_field_fieldvalue AS cff
                   WHERE id_collection=%d AND cff.type='soo' AND cff.id_field=f.id
                   ORDER BY cff.score DESC, f.name ASC""" % self.id
        box += """<select name="sf" class="address">"""
        box += """  <option value="">- %s -""" % msg_latest_first[ln]
        res = run_sql(query)
        if res:
            for row in res:
                box += """  <option value="%s">%s""" % (row[0], row[1])
        else:
            for field in ('title','author','report number','year'):
                box += """  <option value="%s">%s""" % (field, field)                
        box += """</select>"""
        box += """<select name="so" class="address">
                    <option value="a">%s
                    <option value="d">%s
                  </select>""" % (msg_ascending[ln], msg_descending[ln])
        return box 

    def create_rankoptions(self, ln=cdslang):
        "Produces 'Rank options' portal box."
        box=""
        box += """<select name="rm" class="address">"""
        box += """  <option value="">- %s %s -""" % (string.lower(msg_or[ln]), msg_rank_by[ln])
        for (code,name) in get_bibrank_methods(self.id, ln):
            box += """  <option value="%s">%s""" % (code, name)                
        box += """</select>"""
        return box 

    def create_displayoptions(self, ln=cdslang):
        "Produces 'Display options' portal box."
        box=""
        # firstly, display hits per collection selection box:
        box += """<select name="rg" class="address">
           <option value="10">10 %s
           <option value="25">25 %s
           <option value="50">50 %s
           <option value="10">100 %s
           <option value="250">250 %s
           <option value="500">500 %s
           </select>""" % (msg_results[ln], msg_results[ln], msg_results[ln],
                           msg_results[ln], msg_results[ln], msg_results[ln])
        # secondly, display split by collection selection box:
        if self.get_sons():
            box += """<select name="sc" class="address">
            <option value="1">%s
            <option value="0">%s
            </select>""" % (msg_split_by_collection[ln], msg_single_list[ln])
        return box

    def create_formatoptions(self, ln=cdslang):
        "Produces 'Output format options' portal box."
        box = ""
        box += """<select name="of" class="address">
           """
        query = """SELECT f.code,f.name FROM format AS f, collection_format AS cf
                   WHERE cf.id_collection=%d AND cf.id_format=f.id ORDER BY cf.score DESC, f.name ASC"""  % self.id
        res = run_sql(query)
        if res:
            # propose found formats:
            for row in res:
                box += """<option value="%s">%s""" % (row[0],row[1])
        else:
            # no formats are defined for this collection, so propose the default HTML one:
            box += """<option value="hb">HTML %s""" % msg_brief[ln]
        box += """</select>"""        
        return box

    def create_searchwithin_selection_box(self, fieldname='f', value='', ln='en'):
        "Produces 'search within' selection box for the current collection."
        out = ""
        out += """<select name="%s">""" % fieldname
        out += """<option value="">%s""" % get_field_i18nname("any field", ln)
        query = """SELECT f.code,f.name FROM field AS f, collection_field_fieldvalue AS cff
                   WHERE cff.type='sew' AND cff.id_collection=%d AND cff.id_field=f.id
                   ORDER BY cff.score DESC, f.name ASC"""  % self.id
        res = run_sql(query)
        if res:
            # propose found 'search within' fields:
            for row in res:
                out += """<option value="%s"%s>%s""" % (row[0], is_selected(row[0], value), row[1])
        else:
            # no 'search within' fields are defined for this collection, so propose default ones:
            if cfg_cern_site:
                out += """<option value="title"%s>%s""" % (is_selected("title", value), get_field_i18nname("title", ln))
                out += """<option value="author"%s>%s""" % (is_selected("author", value), get_field_i18nname("author", ln))
                out += """<option value="reportnumber"%s>%s""" % (is_selected("reportnumber", value), get_field_i18nname("report number", ln))
                out += """<option value="year"%s>%s""" % (is_selected("year", value), get_field_i18nname("year", ln))
            else:
                out += """<option value="title"%s>- %s""" % (is_selected("title", value), get_field_i18nname("title", ln))
                out += """<option value="author"%s>- %s""" % (is_selected("author", value), get_field_i18nname("author", ln))
                out += """<option value="abstract"%s>- %s""" % (is_selected("abstract", value), get_field_i18nname("abstract", ln))
                out += """<option value="keyword"%s>- %s""" % (is_selected("keyword", value), get_field_i18nname("keyword", ln))
                out += """<option value="reportnumber"%s>- %s""" % (is_selected("reportnumber", value), get_field_i18nname("report number", ln))
                out += """<option value="year"%s>- %s""" % (is_selected("year", value), get_field_i18nname("year", ln))
                out += """<option value="fulltext"%s>%s""" % (is_selected("fulltext", value), get_field_i18nname("fulltext", ln))
                out += """<option value="reference"%s>%s""" % (is_selected("reference", value), get_field_i18nname("reference", ln))
        out += """</select>""" 
        return out

    def create_searchexample(self):
        "Produces search example(s) for the current collection."
        out = "$collSearchExamples = getSearchExample(%d, $se);" % self.id
        return out

    def create_searchfor(self, as=0, ln=cdslang):
        "Produces either Simple or Advanced 'Search for' box for the current collection."
        if as == 1:
            return self.create_searchfor_advanced(ln)
        else:
            return self.create_searchfor_simple(ln)            

    def create_searchfor_simple(self, ln=cdslang):
        "Produces simple 'Search for' box for the current collection."
        # print commentary start:
        out = "<!--create_searchfor_simple()-->"
        out += """<input type="hidden" name="sc" value="1">"""
        out += """<input type="hidden" name="ln" value="%s">""" % ln
        # define URL add-ons for simple and advanced search boxen:
        if self.name != cdsname:
            ssearchurl = "?c=%s&amp;as=0&amp;ln=%s" % (urllib.quote_plus(self.name), ln)
            asearchurl = "?c=%s&amp;as=1&amp;ln=%s" % (urllib.quote_plus(self.name), ln)
        else: # hide cdsname for aesthetical reasons
            ssearchurl = "?as=0&amp;ln=%s" % ln
            asearchurl = "?as=1&amp;ln=%s" % ln
        # define search box elements:
        header = msg_search_records_for[ln] % self.create_nbrecs_info(ln, "","")
        cell_1_left = """<input type="text" name="p" size="40" value="">"""
        cell_1_middle = "%s" % self.create_searchwithin_selection_box(ln=ln)
        cell_1_right = """<input class="formbutton" type="submit" name="action" value="%s"><input class="formbutton" type="submit" name="action" value="%s">""" % (msg_search[ln], msg_browse[ln])
        cell_2 = """<small><a href="%s/help/search/tips.%s.html">%s</a> :: <a href="%s">%s</a></small>""" \
        % (weburl, ln, msg_search_tips[ln], asearchurl, msg_advanced_search[ln])
        # merge them:
        out += """<table class="searchbox">
                   <thead>
                    <tr align="left">
                     <th colspan="3" class="searchboxheader">%s</th>
                    </tr>
                   </thead>
                   <tbody>
                    <tr valign="baseline">
                     <td class="searchboxbody" align="left">%s</td>
                     <td class="searchboxbody" align="left">%s</td>
                     <td class="searchboxbody" align="left">%s</td>
                    </tr>
                    <tr valign="baseline">
                     <td class="searchboxbody" colspan="3" align="right">%s</td>
                    </tr>
                   </tbody>
                  </table>""" % \
              (header, 
               cell_1_left, cell_1_middle, cell_1_right,
               cell_2)
        # print commentary end:
        out += "<!--/create_searchfor_simple()-->"
        return out

    def create_searchfor_advanced(self, ln=cdslang):
        "Produces simple 'Search for' box for the current collection."
        # print commentary start:
        out = "<!--create_searchfor_advanced()-->"
        out += """<input type="hidden" name="as" value="1">"""
        out += """<input type="hidden" name="ln" value="%s">""" % ln
        # define URL add-ons for simple and advanced search boxen:
        if self.name != cdsname:
            ssearchurl = "?c=%s&amp;as=0&amp;ln=%s" % (urllib.quote_plus(self.name), ln)
            asearchurl = "?c=%s&amp;as=1&amp;ln=%s" % (urllib.quote_plus(self.name), ln)
        else: # hide cdsname for aesthetical reasons
            ssearchurl = "?as=0&amp;ln=%s" % ln
            asearchurl = "?as=1&amp;ln=%s" % ln
        # define search box elements:
        header = msg_search_records_for[ln] % self.create_nbrecs_info(ln, "", "") 
        cell_1_left = create_matchtype_box('m1', ln=ln) + """<input type="text" name="p1" size="40" value="">""" 
        cell_1_middle = self.create_searchwithin_selection_box('f1', ln=ln)
        cell_1_right = create_andornot_box('op1', ln=ln)
        cell_2_left = create_matchtype_box('m2', ln=ln) + """<input type="text" name="p2" size="40" value="">"""
        cell_2_middle = self.create_searchwithin_selection_box('f2', ln=ln)
        cell_2_right = create_andornot_box('op2', ln=ln)
        cell_3_left = create_matchtype_box('m3', ln=ln) + """<input type="text" name="p3" size="40" value="">"""
        cell_3_middle = self.create_searchwithin_selection_box('f3', ln=ln)
        cell_3_right = """<input class="formbutton" type="submit" name="search" value="%s"><input class="formbutton" type="submit" name="search" value="%s">&nbsp;""" % (msg_search[ln], msg_browse[ln])
        cell_4 = """<small><a href="%s/help/search/tips.%s.html">%s</a> :: <a href="%s">%s</a></small>""" \
                 % (weburl, ln, msg_search_tips[ln], ssearchurl, msg_simple_search[ln])
        # merge them:
        out += """<table class="searchbox">
                   <thead>
                    <tr>
                     <th class="searchboxheader" colspan="3">%s</th>
                    </tr>
                   </thead>
                   <tbody>
                    <tr valign="bottom">
                      <td nowrap>%s</td>
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody">%s</td>
                    </tr>
                    <tr valign="bottom">
                      <td class="searchboxbody" nowrap>%s</td>
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody">%s</td>
                    </tr>
                    <tr valign="bottom">
                      <td class="searchboxbody" nowrap>%s</td>
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody" nowrap>%s</td>
                    </tr>
                    <tr valign="bottom">
                      <td colspan="3" class="searchboxbody" align="right">%s</td>
                    </tr>
                   </tbody> 
                  </table>""" % \
              (header,
               cell_1_left, cell_1_middle, cell_1_right, \
               cell_2_left, cell_2_middle, cell_2_right, \
               cell_3_left, cell_3_middle, cell_3_right, \
               cell_4)
        # create more search options, if any:
        if self.create_searchoptions():
            out += """<table class="searchbox">
                       <thead> 
                        <tr>
                          <th class="searchboxheader">
                            %s
                          </th>
                        </tr>
                       </thead>
                       <tbody>
                        <tr valign="bottom">
                         <td class="searchboxbody">%s</td>
                        </tr>
                       <tbody> 
                      </table>""" % (msg_search_options[ln], self.create_searchoptions())
        if 0:
            # FIXME: create published in, if appropriate:
            if self.create_publishedin():
                out += self.create_publishedin()
        # arrival date: from/until:
        cell_6_a = self.create_inputdate("d1", ln=ln)
        cell_6_b = self.create_inputdate("d2", ln=ln)
        out += """<table class="searchbox">
                   <thead> 
                    <tr>
                      <th class="searchboxheader">
                        %s
                      </th>
                      <th class="searchboxheader">
                        %s
                      </th>                      
                    </tr>
                   </thead>
                   <tbody>
                    <tr valign="bottom">
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody">%s</td>
                    </tr>
                   </tbody>
                  </table>""" % \
           (msg_added_since[ln], msg_until[ln], cell_6_a, cell_6_b)        
        # sort/rank and display/format options:        
        cell_7_a = self.create_sortoptions(ln) + self.create_rankoptions(ln)
        cell_7_b = self.create_displayoptions(ln)
        cell_7_c = self.create_formatoptions(ln)
        out += """<table class="searchbox">
                   <thead>
                    <tr>
                      <th class="searchboxheader">
                        %s
                      </th>
                      <th class="searchboxheader">
                        %s
                      </th>
                      <th class="searchboxheader">
                        %s
                      </th>
                    </tr>
                   </thead>
                   <tbody>
                    <tr valign="bottom">
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody">%s</td>
                      <td class="searchboxbody">%s</td>
                    </tr>
                   </tbody>
                  </table>""" % \
                      (msg_sort_by[ln], msg_display_results[ln], msg_output_format[ln],                       
                       cell_7_a, cell_7_b, cell_7_c)
        # print commentary end:
        out += "<!--/create_searchfor_advanced()-->"
        return out

    def calculate_reclist(self):
        """Calculate, set and return the (reclist, reclist_with_nonpublic_subcolls) tuple for given collection."""        
        if self.calculate_reclist_run_already:
            # do we have to recalculate?
            return (self.reclist, self.reclist_with_nonpublic_subcolls)
        if options["verbose"] >= 6:
            write_message("... calculating reclist of %s" % self.name)
        reclist = HitSet() # will hold results for public sons only; good for storing into DB
        reclist_with_nonpublic_subcolls = HitSet() # will hold results for both public and nonpublic sons; good for deducing total
                                                   # number of documents
        if not self.dbquery:
            # A - collection does not have dbquery, so query recursively all its sons
            #     that are either non-restricted or that have the same restriction rules
            for coll in self.get_sons():
                coll_reclist, coll_reclist_with_nonpublic_subcolls = coll.calculate_reclist()
                if ((coll.restricted_p() is None) or
                    (coll.restricted_p() == self.restricted_p())):
                    # add this reclist ``for real'' only if it is public 
                    reclist.union(coll_reclist) 
                reclist_with_nonpublic_subcolls.union(coll_reclist_with_nonpublic_subcolls)
        else:
            # B - collection does have dbquery, so compute it:
            reclist = search_pattern(None,self.dbquery)
            reclist_with_nonpublic_subcolls = copy.deepcopy(reclist)
        # deduce the number of records:
        reclist.calculate_nbhits()
        reclist_with_nonpublic_subcolls.calculate_nbhits()
        # store the results:
        self.nbrecs = reclist_with_nonpublic_subcolls._nbhits
        self.reclist = reclist
        self.reclist_with_nonpublic_subcolls = reclist_with_nonpublic_subcolls
        # last but not least, update the speed-up flag:
        self.calculate_reclist_run_already = 1
        # return the two sets:
        return (self.reclist, self.reclist_with_nonpublic_subcolls)

    def update_reclist(self):
        "Update the record universe for given collection; nbrecs, reclist of the collection table."
        if self.update_reclist_run_already:
            # do we have to reupdate?
            return 0
        if options["verbose"] >= 6:
            write_message("... updating reclist of %s (%s recs)" % (self.name, self.nbrecs))
        sys.stdout.flush()
        try:
            query = "UPDATE collection SET nbrecs=%d, reclist='%s' WHERE id=%d" % \
                    (self.nbrecs, escape_string(zlib.compress(Numeric.dumps(self.reclist._set))), self.id)
            res = run_sql(query)
            self.reclist_updated_since_start = 1
        except MySQLdb.Error, e:
            print "Database Query Error %d: %s." % (e.args[0], e.args[1])
            sys.exit(1)        
        # last but not least, update the speed-up flag:
        self.update_reclist_run_already = 1
        return 0

def usage(code, msg=''):
    "Prints usage info."
    if msg:
        sys.stderr.write("Error: %s.\n" % msg)
    sys.stderr.write("Usage: %s <action> [collection][+]\n" % sys.argv[0])
    sys.stderr.write("""Description:
    %s updates the collection cache
    (record universe for a given collection plus web page elements)
    based on WML and MySQL configuration parameters.  
    If the collection name is passed as the second argument, it'll update
    this collection only.  If the collection name is immediately followed
    by a plus sign, it will also update all its desdendants.  The
    top-level collection name may be entered as the void string.\n""" % sys.argv[0])    
    sys.stderr.write("Example: %s update-reclist\n" % sys.argv[0])
    sys.stderr.write("Example: %s update-webpage\n" % sys.argv[0])
    sys.stderr.write("Example: %s update-webpage \"Articles & Preprints\"\n" % sys.argv[0])
    sys.stderr.write("Example: %s update-webpage \"Articles & Preprints\"+\n" % sys.argv[0])
    sys.stderr.write("Example: %s update-webpage \"\"\n" % sys.argv[0])
    sys.stderr.write("Example: %s update-reclist \"\"+\n" % sys.argv[0])
    sys.exit(code)

def get_datetime(var, format_string="%Y-%m-%d %H:%M:%S"):
    """Returns a date string according to the format string.
       It can handle normal date strings and shifts with respect
       to now."""
    date = time.time()
    shift_re=sre.compile("([-\+]{0,1})([\d]+)([dhms])")
    factors = {"d":24*3600, "h":3600, "m":60, "s":1}
    m = shift_re.match(var)
    if m:
        sign = m.groups()[0] == "-" and -1 or 1
        factor = factors[m.groups()[2]]
        value = float(m.groups()[1])
        date = time.localtime(date + sign * factor * value)
        date = time.strftime(format_string, date)
    else:
        date = time.strptime(var, format_string)
        date = time.strftime(format_string, date)        
    return date

def get_current_time_timestamp():
    """Return timestamp corresponding to the current time."""
    return time.strftime("%04Y-%02m-%02d %02H:%02M:%02S", time.localtime())
    
def compare_timestamps_with_tolerance(timestamp1,
                                      timestamp2,
                                      tolerance=0):
    """Compare two timestamps TIMESTAMP1 and TIMESTAMP2, of the form
       '2005-03-31 17:37:26'. Optionally receives a TOLERANCE argument
       (in seconds).  Return -1 if TIMESTAMP1 is less than TIMESTAMP2
       minus TOLERANCE, 0 if they are equal within TOLERANCE limit,
       and 1 if TIMESTAMP1 is greater than TIMESTAMP2 plus TOLERANCE.
    """
    # remove any trailing .00 in timestamps:
    timestamp1 = sre.sub(r'\.[0-9]+$', '', timestamp1)
    timestamp2 = sre.sub(r'\.[0-9]+$', '', timestamp2)
    # first convert timestamps to Unix epoch seconds:
    timestamp1_seconds = calendar.timegm(time.strptime(timestamp1, "%Y-%m-%d %H:%M:%S"))
    timestamp2_seconds = calendar.timegm(time.strptime(timestamp2, "%Y-%m-%d %H:%M:%S"))
    # now compare them:
    if timestamp1_seconds < timestamp2_seconds - tolerance:
        return -1
    elif timestamp1_seconds > timestamp2_seconds + tolerance:
        return 1
    else:
        return 0

def get_database_last_updated_timestamp():
    """Return last updated timestamp for collection-related and
       record-related database tables.
    """
    database_tables_timestamps = []
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'bibrec'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'bibfmt'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'idxWORD%%'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'collection%%'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'portalbox'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'field%%'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'format%%'")))
    database_tables_timestamps.extend(map(lambda x: str(x[11]), run_sql("SHOW TABLE STATUS LIKE 'rnkMETHODNAME'")))
    return max(database_tables_timestamps)

def get_cache_last_updated_timestamp():
    """Return last updated cache timestamp."""
    try:
        f = open(cfg_cache_last_updated_timestamp_file, "r")
    except:
        return "1970-01-01 00:00:00"
    timestamp = f.read()
    f.close()
    return timestamp

def set_cache_last_updated_timestamp(timestamp):
    """Set last updated cache timestamp to TIMESTAMP."""
    try:
        f = open(cfg_cache_last_updated_timestamp_file, "w")
    except:
        pass
    f.write(timestamp)
    f.close()
    return timestamp

def write_message(msg, stream=sys.stdout):
    """Prints message and flush output stream (may be sys.stdout or sys.stderr)."""
    if stream == sys.stdout or stream == sys.stderr:
        stream.write(time.strftime("%Y-%m-%d %H:%M:%S --> ", time.localtime()))
        stream.write("%s\n" % msg)
        stream.flush()
    else:
        sys.stderr.write("Unknown stream %s.  [must be sys.stdout or sys.stderr]\n" % stream)

def task_sig_sleep(sig, frame):
    """Signal handler for the 'sleep' signal sent by BibSched."""
    if options["verbose"] >= 9:
        write_message("got signal %d" % sig)
    write_message("sleeping...")
    task_update_status("SLEEPING")
    signal.pause() # wait for wake-up signal

def task_sig_wakeup(sig, frame):
    """Signal handler for the 'wakeup' signal sent by BibSched."""
    if options["verbose"] >= 9:
        write_message("got signal %d" % sig)
    write_message("continuing...")
    task_update_status("CONTINUING")

def task_sig_stop(sig, frame):
    """Signal handler for the 'stop' signal sent by BibSched."""
    if options["verbose"] >= 9:
        write_message("got signal %d" % sig)
    write_message("stopping...")
    task_update_status("STOPPING")
    pass # FIXME: is there anything to be done?
    task_update_status("STOPPED")
    sys.exit(0)
    
def task_sig_suicide(sig, frame):
    """Signal handler for the 'suicide' signal sent by BibSched."""
    if options["verbose"] >= 9:
        write_message("got signal %d" % sig)
    write_message("suiciding myself now...")
    task_update_status("SUICIDING")
    write_message("suicided")
    task_update_status("SUICIDED")
    sys.exit(0)

def task_sig_unknown(sig, frame):
    """Signal handler for the other unknown signals sent by shell or user."""
    write_message("unknown signal %d ignored" % sig) # do nothing for other signals

def authenticate(user, header="WebColl Task Submission", action="runwebcoll"):
    """Authenticate the user against the user database.
       Check for its password, if it exists.
       Check for action access rights.
       Return user name upon authorization success,
       do system exit upon authorization failure.
       """
    print header
    print "=" * len(header)
    if user == "":
        print >> sys.stdout, "\rUsername: ",
        user = string.strip(string.lower(sys.stdin.readline()))
    else:
        print >> sys.stdout, "\rUsername: ", user        
    ## first check user pw:
    res = run_sql("select id,password from user where email=%s", (user,), 1)
    if not res:
        print "Sorry, %s does not exist." % user
        sys.exit(1)        
    else:
        (uid_db, password_db) = res[0]
        if password_db:
            password_entered = getpass.getpass()
            if password_db == password_entered:
                pass
            else:
                print "Sorry, wrong credentials for %s." % user
                sys.exit(1)
        ## secondly check authorization for the action:
        (auth_code, auth_message) = acc_authorize_action(uid_db, action)
        if auth_code != 0:
            print auth_message
            sys.exit(1)
    return user

def task_submit(options):
    """Submits task to the BibSched task queue.  This is what people will be invoking via command line."""
    ## sanity check: remove eventual "task" option:
    if options.has_key("task"):
        del options["task"]
    ## authenticate user:
    user = authenticate(options.get("user", ""))
    ## submit task:
    if options["verbose"] >= 9:
        print ""
        write_message("storing task options %s\n" % options)
    task_id = run_sql("""INSERT INTO schTASK (id,proc,user,runtime,sleeptime,status,arguments)
                         VALUES (NULL,'webcoll',%s,%s,%s,'WAITING',%s)""",
                      (user, options["runtime"], options["sleeptime"], marshal.dumps(options)))
    ## update task number: 
    options["task"] = task_id
    run_sql("""UPDATE schTASK SET arguments=%s WHERE id=%s""", (marshal.dumps(options),task_id))
    write_message("Task #%d submitted." % task_id)    
    return task_id

def task_update_progress(msg):
    """Updates progress information in the BibSched task table."""
    global task_id
    return run_sql("UPDATE schTASK SET progress=%s where id=%s", (msg, task_id))

def task_update_status(val):
    """Updates status information in the BibSched task table."""
    global task_id
    return run_sql("UPDATE schTASK SET status=%s where id=%s", (val, task_id))    

def task_read_status(task_id):
    """Read status information in the BibSched task table."""
    res = run_sql("SELECT status FROM schTASK where id=%s", (task_id,), 1)
    try:
        out = res[0][0]
    except:
        out = 'UNKNOWN'
    return out

def task_get_options(id):
    """Returns options for the task 'id' read from the BibSched task queue table."""
    out = {}
    res = run_sql("SELECT arguments FROM schTASK WHERE id=%s AND proc='webcoll'", (id,))
    try:
        out = marshal.loads(res[0][0])
    except:
        write_message("Error: WebColl task %d does not seem to exist." % id)
        sys.exit(1)
    return out

def task_run():
    """Run the WebColl task by fetching arguments from the BibSched task queue.
       This is what BibSched will be invoking via daemon call.
       The task will update collection reclist cache and collection web pages for
       given collection. (default is all).
       Arguments described in usage() function.
       Return 1 in case of success and 0 in case of failure."""
    global task_id, options
    task_run_start_timestamp = get_current_time_timestamp()
    options = task_get_options(task_id) # get options from BibSched task table
    ## check task id:
    if not options.has_key("task"):
        write_message("Error: The task #%d does not seem to be a WebColl task." % task_id)
        return 0
    ## check task status:
    task_status = task_read_status(task_id)
    if task_status != "WAITING":
        write_message("Error: The task #%d is %s.  I expected WAITING." % (task_id, task_status))
        return 0
    ## we can run the task now:
    if options["verbose"]:
        write_message("Task #%d started." % task_id)
    task_update_status("RUNNING")
    ## initialize signal handler:
    signal.signal(signal.SIGUSR1, task_sig_sleep)
    signal.signal(signal.SIGTERM, task_sig_stop)
    signal.signal(signal.SIGABRT, task_sig_suicide)
    signal.signal(signal.SIGCONT, task_sig_wakeup)
    signal.signal(signal.SIGINT, task_sig_unknown)
    colls = []
    # decide whether we need to run or not, by comparing last updated timestamps:
    if options["verbose"] >= 3:
        write_message("Database timestamp is %s." % get_database_last_updated_timestamp())
        write_message("Collection cache timestamp is %s." % get_cache_last_updated_timestamp())
    if options.has_key("force") or \
       compare_timestamps_with_tolerance(get_database_last_updated_timestamp(),
                                         get_cache_last_updated_timestamp(),
                                         cfg_cache_last_updated_timestamp_tolerance) >= 0:
        ## either forced update was requested or cache is not up to date, so recreate it:
        # firstly, decide which collections to do:
        if options.has_key("collection"):
            coll = get_collection(options["collection"])
            if coll.id == None:
                usage(1, 'Collection %s does not exist' % coll.name)
            colls.append(coll)
        else:
            res = run_sql("SELECT name FROM collection ORDER BY id")
            for row in res:
                colls.append(get_collection(row[0]))            
        # secondly, update collection reclist cache:
        i = 0
        for coll in colls:
            i += 1
            if options["verbose"]:
                write_message("%s / reclist cache update" % coll.name)
            coll.calculate_reclist()
            coll.update_reclist()
            task_update_progress("Part 1/2: done %d/%d" % (i,len(colls)))
        # thirdly, update collection webpage cache:
        i = 0
        for coll in colls:
            i += 1
            if options["verbose"]:
                write_message("%s / web cache update" % coll.name)
            coll.update_webpage_cache()
            task_update_progress("Part 2/2: done %d/%d" % (i,len(colls)))

        # finally update the cache last updated timestamp:
        # (but only when all collections were updated, not when only
        # some of them were forced-updated as per admin's demand)
        if not options.has_key("collection"):
            set_cache_last_updated_timestamp(task_run_start_timestamp)
            if options["verbose"] >= 3:
                write_message("Collection cache timestamp is set to %s." % get_cache_last_updated_timestamp())
    else:
        ## cache up to date, we don't have to run
        if options["verbose"]:
            write_message("Collection cache is up to date, no need to run.")        
        pass 
    ## we are done:
    task_update_progress("Done.")
    task_update_status("DONE")
    if options["verbose"]:
        write_message("Task #%d finished." % task_id)
    return 1

def usage(exitcode=1, msg=""):
    """Prints usage info."""
    if msg:
        sys.stderr.write("Error: %s.\n" % msg)
    sys.stderr.write("Usage: %s [options]\n" % sys.argv[0])
    sys.stderr.write("Command options:\n")
    sys.stderr.write("  -c, --collection\t Update cache for the given collection only. [all]\n")
    sys.stderr.write("  -f, --force\t Force update even if cache is up to date. [no]\n")
    sys.stderr.write("Scheduling options:\n")
    sys.stderr.write("  -u, --user=USER \t User name to submit the task as, password needed.\n")
    sys.stderr.write("  -t, --runtime=TIME \t Time to execute the task (now), e.g.: +15s, 5m, 3h, 2002-10-27 13:57:26\n")
    sys.stderr.write("  -s, --sleeptime=SLEEP \t Sleeping frequency after which to repeat task (no), e.g.: 30m, 2h, 1d\n")
    sys.stderr.write("General options:\n")
    sys.stderr.write("  -h, --help      \t\t Print this help.\n")
    sys.stderr.write("  -V, --version   \t\t Print version information.\n")
    sys.stderr.write("  -v, --verbose=LEVEL   \t Verbose level (from 0 to 9, default 1).\n")
    sys.stderr.write("""Description: %s updates the collection cache
    (record universe for a given collection plus web page elements)
    based on WML and MySQL configuration parameters.  
    If the collection name is passed as the second argument, it'll update
    this collection only.  If the collection name is immediately followed
    by a plus sign, it will also update all its desdendants.  The
    top-level collection name may be entered as the void string.\n""" % sys.argv[0])    
    sys.exit(exitcode)

def main():
    """Main function that analyzes command line input and calls whatever is appropriate.
       Useful for learning on how to write BibSched tasks."""
    global task_id
    ## parse command line:
    if len(sys.argv) == 2 and sys.argv[1].isdigit():
        ## A - run the task
        task_id = int(sys.argv[1])
        try:
            if not task_run():
                write_message("Error occurred.  Exiting.", sys.stderr)
        except StandardError, e:
            write_message("Unexpected error occurred: %s." % e, sys.stderr)
            write_message("Traceback is:", sys.stderr)
            traceback.print_tb(sys.exc_info()[2])
            write_message("Exiting.", sys.stderr)
            task_update_status("ERROR")                                   
    else:
        ## B - submit the task
        # set default values:
        options["runtime"] = time.strftime("%Y-%m-%d %H:%M:%S") 
        options["verbose"] = 1
        options["sleeptime"] = ""
        # set user-defined options:
        try:
            opts, args = getopt.getopt(sys.argv[1:], "hVv:u:s:t:c:f",
                                       ["help", "version", "verbose=","user=","sleep=","time=","collection=","force"])
        except getopt.GetoptError, err:
            usage(1, err)
        try:
            for opt in opts:
                if opt[0] in ["-h", "--help"]:
                    usage(0)
                elif opt[0] in ["-V", "--version"]:
                    print __version__
                    sys.exit(0)
                elif opt[0] in [ "-u", "--user"]:
                    options["user"] = opt[1]
                elif opt[0] in ["-v", "--verbose"]:
                    options["verbose"] = int(opt[1])
                elif opt[0] in [ "-s", "--sleeptime" ]:
                    get_datetime(opt[1]) # see if it is a valid shift
                    options["sleeptime"] = opt[1]
                elif opt[0] in [ "-t", "--runtime" ]:
                    options["runtime"] = get_datetime(opt[1])
                elif opt[0] in [ "-c", "--collection"]:
                    options["collection"] = opt[1]
                elif opt[0] in [ "-f", "--force"]:
                    options["force"] = 1
                else:
                    usage(1)
        except StandardError, e:
            usage(e)        
        task_submit(options)
    return

### okay, here we go:
if __name__ == '__main__':    
    main()
