## $Id$
## Script that creates collection pages, starting from the collection
## passed to the script as an argument.

## This file is part of the CERN Document Server Software (CDSware).
## Copyright (C) 2002 CERN.
##
## The CDSware is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public License as
## published by the Free Software Foundation; either version 2 of the
## License, or (at your option) any later version.
##
## The CDSware is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.  
##
## You should have received a copy of the GNU General Public License
## along with CDSware; if not, write to the Free Software Foundation, Inc.,
## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

## read config variables:
#include "config.wml"
#include "configbis.wml"

## start Python:
<protect>#!</protect><PYTHON>
<protect>## $Id$</protect>
<protect>## DO NOT EDIT THIS FILE! IT WAS AUTOMATICALLY GENERATED FROM CDSware WML SOURCES.</protect>
"""Creates CDSware collection specific pages, using WML and MySQL configuration tables."""

## fill config variables:
pylibdir = "<LIBDIR>/python"
wmlexec = "<WML>"

### okay, rest of the Python code goes below ###

## import modules:
try:
    import sys
    import cgi
    import re
    import os
    import math
    import string
    import urllib
    import zlib
    import MySQLdb
    import Numeric
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

try:
    sys.path.append('%s' % pylibdir)
    from cdsware.config import *
    from cdsware.search_engine import HitList, search_pattern
    from cdsware.search_engine_config import cfg_author_et_al_threshold, cfg_instant_browse
    from cdsware.dbquery import run_sql    
except ImportError, e:
    print "Error: %s" % e
    import sys
    sys.exit(1)

## auxiliary functions:
def mymkdir(newdir, mode=0777):
    """works the way a good mkdir should :)
        - already exists, silently complete
        - regular file in the way, raise an exception
        - parent directory(ies) does not exist, make them as well
    """
    if os.path.isdir(newdir):
        pass
    elif os.path.isfile(newdir):
        raise OSError("a file with the same name as the desired " \
                      "dir, '%s', already exists." % newdir)
    else:
        head, tail = os.path.split(newdir)
        if head and not os.path.isdir(head):
            mymkdir(head, mode)
        if tail:
	    os.umask(022)
            os.mkdir(newdir, mode)

def nice_number(num):
    "Returns nice number when using comma as thousands separator."
    chars_in = list(str(num))
    num = len(chars_in)
    chars_out = []
    for i in range(0,num):
        if i % 3 == 0 and i != 0:
            chars_out.append(',')
        chars_out.append(chars_in[num-i-1])
    chars_out.reverse()
    return ''.join(chars_out)

def escape_string(s):
    "Escapes special chars in string.  For MySQL queries."
    s = MySQLdb.escape_string(s)
    return s

def secure_path(p):
    "Escapes special chars in path, like '&' and ' '.  For filename creation."
    p = re.sub(' ', '_', p)
    p = re.sub('\\\\', '_', p)
    p = re.sub('\&', 'and', p)
    p = re.sub('\(', '', p)
    p = re.sub('\)', '', p)
    return p

def is_selected(var, fld):
    "Checks if the two are equal, and if yes, returns ' selected'.  Useful for select boxes."
    if var == fld:
        return " selected"
    else:
        return ""

def create_html_header(name='Search', navtrail='', cdspageboxlefttopadd='', cdspageboxleftbottomadd='',
                       cdspageboxrighttopadd='', cdspageboxrightbottomadd=''):
    "Returns standard HTML header."
    # NOTE: in order to let 'create_collection_pages' write the
    # protect tag in 'index.wml' you need to do it in a funny way,
    # because otherwise WML would interpret the protect tag already
    # when compiling this program (create_collection_pages.wml)!  This
    # is because the source file itself it is also handled by WML. :-)
    out = """#include "cdspage.wml" \\\
        title="%s" \\\
        navbar_name="main" \\\
        navbar_select="searchbiblinfo" """ % name
    if navtrail:
        out += """\\\
        navtrail_body="<%s>%s</%s>" """ % ('protect', navtrail, 'protect')
    else:
        out += """\\\
        navtrail_body="" """
    if cdspageboxlefttopadd:
        out += """\\\
        cdspageboxlefttopadd="<%s>%s</%s>" """ % ('protect', cdspageboxlefttopadd, 'protect')
    if cdspageboxleftbottomadd:
        out += """\\\
        cdspageboxleftbottomadd="<%s>%s</%s>" """ % ('protect', cdspageboxleftbottomadd, 'protect')
    if cdspageboxrighttopadd:
        out += """\\\
        cdspageboxrighttopadd="<%s>%s</%s>" """ % ('protect', cdspageboxrighttopadd, 'protect')
    if cdspageboxrightbottomadd:
        out += """\\\
        cdspageboxrightbottomadd="<%s>%s</%s>" """ % ('protect', cdspageboxrightbottomadd, 'protect')
    out += """
    <protect>
    <?
    include("%s/sessinit.inc.shtml");
    function IsSelectedOption($var,$string) {
        if ($var == $string) {
            return " selected";
        }
    }
    function GetNbDocInCollection($collname, $prolog=' <small class="nbdoccoll">(', $epilog=')</small>', $doNiceNumber=1) {
       global $SESS_DBH;
       $out = "";
       $query = "SELECT nbrecs FROM collection WHERE name='".$collname."'";
       $res = mysql_query($query, $SESS_DBH);
       if (mysql_num_rows($res)) {
           if ($row = mysql_fetch_row($res)) {
               $out = $row[0];
           }
           mysql_free_result($res);
       }       
       if ($doNiceNumber == 1) {
           $out = number_format($out);
       }
       $out = $prolog.$out.$epilog;       
       return $out;
    }
    ?>    
    </protect>""" % (webdir)
    return out

def create_html_footer():
    "Returns standard HTML footer."
    return ""

def create_andornot_box(name='op', value=''):
    "Returns HTML code for the AND/OR/NOT selection box."
    out = """
    <select name="%s">
    <option value="a"%s>AND
    <option value="o"%s>OR
    <option value="n"%s>AND NOT
    </select>
    """ % (name, is_selected('a', value), is_selected('o', value), is_selected('n', value))
    return out

def create_matchtype_box(name='m', value=''):
    "Returns HTML code for the 'match type' selection box."
    out = """
    <select name="%s">
    <option value="a"%s>All of the words:
    <option value="o"%s>Any of the words:
    <option value="p"%s>Phrase/substring:
    <option value="r"%s>Regular expression:
    <option value="e"%s>Exact value:
    </select>
    """ % (name, is_selected('a', value), is_selected('o', value), is_selected('p', value), 
                 is_selected('r', value), is_selected('e', value))
    return out

def get_field(recID, tag):
    "Gets list of field 'tag' for the record with 'recID' system number."

    out = []
    digit = tag[0:2]

    bx = "bib%sx" % digit
    bibx = "bibrec_bib%sx" % digit
    query = "SELECT bx.value FROM %s AS bx, %s AS bibx WHERE bibx.id_bibrec='%s' AND bx.id=bibx.id_bibxxx AND bx.tag='%s'" \
            % (bx, bibx, recID, tag)
    res = run_sql(query)
    for row in res:        
        out.append(row[0])
    return out

def print_record(recID, format='hb'):
    "Prints record 'recID' formatted accoding to 'format'."

    out = ""
    # HTML brief format by default
    query = "SELECT value FROM bibfmt WHERE id_bibrec='%s' AND format='%s'" % (recID, format)
    res = run_sql(query, None, 1)
    if res:
        # record 'recID' is formatted in 'format', so print it
        out += "%s" % zlib.decompress(res[0][0])
    else:
        # record 'recID' does not exist in format 'format', so print some default format:
        # firstly, title:
        titles = get_field(recID, "245__a")
        for title in titles:
            out += "<strong>%s</strong> " % cgi.escape(title)
        # secondly, authors:
        authors = get_field(recID, "100__a") + get_field(recID, "700__a")
        if authors:
            out += " / "
            for i in range (0,cfg_author_et_al_threshold):
                if i < len(authors):
                    out += """<a href="%s/search.py?p=%s&f=author">%s</a> ;""" % (weburl, urllib.quote(authors[i]), cgi.escape(authors[i]))
            if len(authors) > cfg_author_et_al_threshold:
                out += " <em>et al.</em>"
        # thirdly, date of creation:
        dates = get_field(recID, "260__c")
        for date in dates:
            out += " %s." % cgi.escape(date)
        # thirdly bis, report numbers:
        rns = get_field(recID, "037__a")
        for rn in rns:
            out += """ <small class="quicknote">[%s]</small>""" % cgi.escape(rn)
        rns = get_field(recID, "088__a")
        for rn in rns:
            out += """ <small class="quicknote">[%s]</small>""" % cgi.escape(rn)
        # fourthly, beginning of abstract:
        abstracts = get_field(recID, "520__a")
        for abstract in abstracts:
            out += "<br><small>%s [...]</small>" % cgi.escape(abstract[:1+string.find(abstract, '.')])
        # fifthly, fulltext link:
        urls_z = get_field(recID, "8564_z")
        urls_u = get_field(recID, "8564_u")
        for idx in range(0,len(urls_u)):
            out += """<br><small class="note"><a class="note" href="%s">%s</a></small>""" % (urls_u[idx], urls_u[idx])

    # at the end of HTML mode, print "Detailed record" and "Mark record" functions:
    out +=  """<br><span class="moreinfo"><a class="moreinfo" href="%s/search.py?id=%s">Detailed record</a>""" \
           % (weburl, recID)
    #out += """- <input name="mark[]" type="checkbox" value="%s"> Mark record</span>""" % recID

    return out

## class Collection:
class Collection:
    "Holds the information on collections (id,name,nameshort,dbquery)."

    def __init__(self, name=""):
        "Creates collection instance by querying the MySQL configuration database about 'name'."
        if not name:
            self.name = cdsname # by default we are working on the home page
            self.id = 1
            self.dbquery = None
            self.nbrecs = None
            self.reclist = None
        else:
            self.name = name
            query = "SELECT id,nameshort,dbquery FROM collection WHERE name='%s'" % escape_string(name)
            try:
                res = run_sql(query, None, 1)
                if res:
                    self.id = res[0][0]
                    self.nameshort = res[0][1]
                    self.dbquery = res[0][2]
                    self.nbrecs = None
                    self.reclist = None
                else: # collection does not exist!
                    self.id = None
                    self.nameshort = None
                    self.dbquery = None
                    self.nbrecs = None
                    self.reclist = None
            except MySQLdb.Error, e:
                print "Error %d: %s" % (e.args[0], e.args[1])
                sys.exit(1)

    def get_ancestors(self):
        "Returns list of ancestors of the current collection."
        ancestors = []
        id_son = self.id
        while 1:
            query = "SELECT cc.id_dad,c.name FROM collection_collection AS cc, collection AS c "\
                    "WHERE cc.id_son=%d AND c.id=cc.id_dad" % int(id_son)
            res = run_sql(query, None, 1)
            if res:
                col_ancestor = Collection(res[0][1])
                ancestors.append(col_ancestor)
                id_son = res[0][0]
            else:
                break
        ancestors.reverse()
        return ancestors

    def get_sons(self):
        "Returns list of direct sons of the current collection."
        sons = []
        id_dad = self.id
        query = "SELECT cc.id_son,c.name FROM collection_collection AS cc, collection AS c "\
                "WHERE cc.id_dad=%d AND c.id=cc.id_son ORDER BY score DESC, c.name ASC" % int(id_dad)
        res = run_sql(query)
        for row in res:
            sons.append(Collection(row[1]))
        return sons

    def get_descendants(self):
        "Returns list of all descendants of the current collection."
        descendants = []
        id_dad = self.id
        query = "SELECT cc.id_son,c.name FROM collection_collection AS cc, collection AS c "\
                "WHERE cc.id_dad=%d AND c.id=cc.id_son ORDER BY score DESC" % int(id_dad)
        res = run_sql(query)
        for row in res:
            col_desc = Collection(row[1])
            descendants.append(col_desc)
            descendants += col_desc.get_descendants()
        return descendants

    def get_collection_filename(self):
        "Returns the filename of the current collection page."        
        filename = self.get_collection_dirname() + "index.shtml"
        return filename

    def get_collection_dirname(self):
        "Returns the directory name of the current collection page."
        dirname = webdir + "/"
        for dad in self.get_ancestors():
            if dad.name != cdsname:
                dirname += secure_path(dad.name) + "/"
        if self.id>1: # exclude Home collection
            dirname += secure_path(self.name) + "/"
        return dirname

    def write_page(self, body=''):
        "Calls WML engine and writes resulting HTML page in the collection hierarchy."
        # open file:
        dirname = self.get_collection_dirname()
        mymkdir(dirname)
        filename = self.get_collection_filename()
        try:
	    os.umask(022)
            f = open("index.wml", "w")
        except IOError, v:
            try:
                (code, message) = v
            except:
                code = 0
                message = v
            print "I/O Error: " + str(message) + " (" + str(code) + ")"
            sys.exit(1)
        # print user info:
        print "...... creating %s" % filename
        sys.stdout.flush()
        # print page body:
        f.write(body)
        # close file:
        f.close()
        # at the end, call WML:        
        os.system("%s -o %s index.wml" % (wmlexec, filename))

    def create_page(self):
        """Creates collection page header, navtrail, body (including left and right stripes) and footer.
           Calls weite_page() afterwards."""
        
        body = "<!--pagebody-->"
        body += """<form action="%s/search.py" method="get">""" % weburl
#        body += """<strong class="headline"><span class="h1">%s</span></strong>""" % self.name
#        body += self.create_navtrail("""<br><table border=0 cellspacing=0 cellpadding=0><tr><td width="30"></td><td><small>""","","&gt;","","</small></td></tr></table>",1)
        body += "" + self.create_searchfor()
        body += """<br><table cellspacing="2" cellpadding="2" border="0"><tr>"""
        body += """<td valign="top">""" + self.create_narrowsearch() + "</td>"
        body += """<td valign="top"><table>"""
        if self.create_searchoptions():
            body += "<tr><td>"+ self.create_searchoptions() + "</td></tr>" 
        if self.create_displayoptions():
            body += "<tr><td>"+ self.create_displayoptions() + "</td></tr>" 
        if self.create_sortoptions():
            body += "<tr><td>"+ self.create_sortoptions() + "</td></tr>" 
        if self.create_formatoptions():
            body += "<tr><td>"+ self.create_formatoptions() + "</td></tr>" 
        body += """</table></td>"""
        body += "</tr></table>"
        body += """</form>"""
        body += "<!--/pagebody-->"
        self.write_page(create_html_header(self.name,
                                           self.create_navtrail("<small>","","&gt;","","</small>",1),
                                           self.create_portalbox("lt"),
                                           self.create_portalbox("lb"),
                                           self.create_portalbox("rt"),
                                           self.create_portalbox("rb")                                           
                                           ) +
                        body + create_html_footer())

    def create_navtrail(self, \
#                        header="""<table width="100%%"><tr><td class="navtrail">
#                                  <img width="16" src="%s/img/iconnext.gif" border=0 alt="x">""" % webdir, \
                        header="""<table width="100%" border=0 cellspacing=0 cellpadding=0><tr><td class="navtrail"><small>""", \
                        prolog="", \
                        separator="&gt;", \
                        epilog="", \
                        footer="</small></td></tr></table>",
                        exclude_root=0):
        "Creates navigation trail, i.e. links to collection ancestors."
        # firstly, display navtrail prologue:
        navtrail = header        
        # first, list list of ancestors:
        for dad in self.get_ancestors():
            navtrail += """%s <a class="navtrail" href="%s/goto.shtml?c=%s">%s</a> %s %s """ % \
                        (prolog, weburl, urllib.quote(dad.name), dad.name, epilog, separator)
        # then print self:
        if self.id > 1 or (self.id==1 and not exclude_root):
            navtrail += """%s %s %s""" % (prolog, self.name, epilog)
        # last, print navtrail epilogue:
        navtrail += footer
        # sanity check:
        if navtrail == header + prolog + epilog + footer:
            return ""
        return navtrail

    def create_portalbox(self, position="rt"):
        """Creates portalboxes of the position 'position' by consulting MySQL configuration database.
           The position may be: 'lt'='left top', 'lb'='left bottom', 'rt'='right top', 'rb'='right bottom',
           'tl'='top left', 'tr'='top right', 'bl'='bottom left', 'br='bottom right'."""
        out = ""
        query = "SELECT p.title,p.body FROM portalbox AS p, collection_portalbox AS cp "\
                " WHERE cp.id_collection=%d AND p.id=cp.id_portalbox AND cp.position='%s' "\
                " ORDER BY cp.score DESC" % (self.id, position)
        res = run_sql(query)
        for row in res:
            if out:
                out += "<br>"
            out += "<strong>" + row[0] + "</strong><br>" + row[1]
        return out

    def create_narrowsearch(self):
        "Creates list of collection descendants under narrow search."
        narrowsearch=""
        # firstly write silent 'cc' (=current collection) argument:
        narrowsearch += """<input type="hidden" name="cc" value="%s">""" % self.name
        # then get list of sons and analyse it:
        sons = self.get_sons()
        # decide upon writing style: if there are grandchildren, then print in bold        
        descendants = self.get_descendants()
        if len(descendants)>len(sons):
            style_prolog = "<strong>"
            style_epilog = "</strong>"
        else:
            style_prolog = ""
            style_epilog = ""
        # are there some sons?
        if len(sons):
            narrowsearch += "<small><strong>Narrow search:</strong></small>"
            # iterate through sons:
            for son in sons:
                narrowsearch += """<table><tr>
                                   <td valign="top"><input type=checkbox name="c" value="%s" checked>&nbsp;</td>
                                   <td valign="top"><a href="%s/goto.shtml?c=%s">%s%s%s</a><? echo GetNbDocInCollection("%s"); ?>""" % \
                                       (son.name, weburl, urllib.quote(son.name), style_prolog, son.name, style_epilog, son.name)
                grandsons = son.get_sons()
                nb_grandsons = len(grandsons)
                if nb_grandsons:
                    # print all grandsons:
                    narrowsearch += """<br>"""
                    for i in range(0,nb_grandsons):
                        narrowsearch += """<a href="%s/goto.shtml?c=%s">%s</a><? echo GetNbDocInCollection("%s"); ?>  """ % \
                                        (weburl, urllib.quote(grandsons[i].name), grandsons[i].name, grandsons[i].name)
                narrowsearch += """</td></tr></table>""" 
        else:
            # no sons, so print some collection info:
            narrowsearch += self.create_instant_browse()

        return narrowsearch

    def create_instant_browse(self, rg=cfg_instant_browse):
        "Searches database and produces list of last 'rg' records."
        box = ""
        url = "%s/search.py?cc=%s" % (weburl, urllib.quote(self.name))
        if self.nbrecs:
            box += """<small><strong>Latest additions: </strong>"""
            # firstly, get last 'rg' records:
            box += "<ol>"
            recIDs = Numeric.nonzero(self.reclist)
            for idx in range(self.nbrecs-1, self.nbrecs-rg-1, -1):
                if idx>=0:
                    box += """<li style="font-size: small;"><p><small>""" + print_record(recIDs[idx]) + "</small></p>"
            box += "</ol>"
            if self.nbrecs > rg:
                box += """<div align="right"><small><a href="%s">[list all %s records]</a></small></div>""" % (url, nice_number(self.nbrecs))
        else:
            box += """<small><strong>No records! </strong></small><br> This collection does not contain any document yet."""
        return box

    def create_searchoptions(self):
        "Produces 'Search options' portal box."
        # TODO: distinguish name/nameshort, i.e. naviguable/non-naviguable search options
        box=""
        query = """SELECT DISTINCT(cff.id_field),f.code,f.nameshort FROM collection_field_fieldvalue AS cff, field AS f
                   WHERE cff.id_collection=%d AND cff.id_fieldvalue IS NOT NULL AND cff.id_field=f.id
                   ORDER BY cff.score DESC""" % self.id
        res = run_sql(query)
        if res:
            box += "<small><strong>Search options:</strong></small><br>"
            for row in res:
                field_id = row[0]
                field_code = row[1]
                field_name = row[2]                
                query_bis = """SELECT fv.value,fv.nameshort FROM fieldvalue AS fv, collection_field_fieldvalue AS cff
                               WHERE cff.id_collection=%d AND cff.type='seo' AND cff.id_field=%d AND fv.id=cff.id_fieldvalue
                               ORDER BY cff.score_fieldvalue DESC, cff.score DESC, fv.nameshort ASC""" % (self.id, field_id)
                res_bis = run_sql(query_bis)                
                if res_bis:
                    box += """<select name="%s">""" % field_code
                    box += """<option value="">any %s""" % field_name
                    for row_bis in res_bis:
                        box += """<option value="%s">%s""" % (cgi.escape(row_bis[0], 1), row_bis[1])
                    box += """</select>"""
        return box

    def create_sortoptions(self):
        "Produces 'Sort options' portal box."
        box=""
        query = """SELECT f.code,f.nameshort FROM field AS f, collection_field_fieldvalue AS cff
                   WHERE id_collection=%d AND cff.type='soo' AND cff.id_field=f.id
                   ORDER BY cff.score DESC, f.name ASC""" % self.id
        res = run_sql(query)
        if res:
            box += "<small><strong>Sort results:</strong></small><br>"
            box += """<select name="sf">"""
            box += """<option value="">no sort"""
            for row in res:
                box += """<option value="%s">sort by %s""" % (row[0], row[1])
            box += """</select>"""
            box += """<select name="so">
                      <option value="a">asc.
                      <option value="d">desc.
                      </select>"""
        return box

    def create_displayoptions(self):
        "Produces 'Display options' portal box."
        box=""
        box += "<small><strong>Display results:</strong></small><br>"
        # firstly, display hits per collection selection box:
        box += """
        <? echo "<select name=\\\"rg\\\">";
           echo "<option value=10" . IsSelectedOption($p_rg,10) . ">10 results";
           echo "<option value=25" . IsSelectedOption($p_rg,25) . ">25 results";
           echo "<option value=50" . IsSelectedOption($p_rg,50) . ">50 results";
           echo "<option value=100". IsSelectedOption($p_rg,100) . ">100 results";
           echo "<option value=250". IsSelectedOption($p_rg,250) . ">250 results";
           echo "<option value=500". IsSelectedOption($p_rg,500) . ">500 results";
           echo "</select>";
        ?>"""
        # secondly, display split by collection selection box:
        if self.get_sons():
            box += """<br>
            <? echo "<select name=\\\"sc\\\">";
            echo "<option value=\\\"0\\\"" . IsSelectedOption($p_sc,0) . ">grouped together";
            echo "<option value=\\\"1\\\"" . IsSelectedOption($p_sc,1) . ">split by collection";
            echo "</select>";
            ?>"""        
        return box

    def create_formatoptions(self):
        "Produces 'Output format options' portal box."
        box = "<small><strong>Output format:</strong></small>"
        box += """<br>
        <? echo "<select name=\\\"of\\\">";
           """
        query = """SELECT f.code,f.name FROM format AS f, collection_format AS cf
                   WHERE cf.id_collection=%d AND cf.id_format=f.id ORDER BY cf.score DESC, f.name ASC"""  % self.id
        res = run_sql(query)
        if res:
            # propose found formats:
            for row in res:
                box += """
                   echo "<option value=\\\"%s\\\"" . IsSelectedOption($p_of,'%s') . ">%s";
                """ % (row[0],row[0],row[1])
        else:
            # no formats are defined for this collection, so propose the default HTML one:
            box += """
              echo "<option value=\\\"hb\\\"" . IsSelectedOption($p_of,'hb') . ">HTML brief";"""
        box += """
           echo "</select>";
        ?>"""        
        return box

    def create_searchwithin_selection_box(self, fieldname='f', value=''):
        "Produces 'search within' selection box for the current collection."
        out = ""
        out += """<select name="%s">""" % fieldname
        out += """<option value="">any field"""
        query = """SELECT f.code,f.name FROM field AS f, collection_field_fieldvalue AS cff
                   WHERE cff.type='sew' AND cff.id_collection=%d AND cff.id_field=f.id
                   ORDER BY cff.score DESC, f.name ASC"""  % self.id
        res = run_sql(query)
        if res:
            # propose found 'search within' fields:
            for row in res:
                out += """<option value="%s"%s>%s""" % (row[0], is_selected(row[0], value), row[1])
        else:
            # no 'search within' fields are defined for this collection, so propose default ones:
            out += """<option value="title"%s>title""" % is_selected("title", value)
            out += """<option value="author"%s>author""" % is_selected("author", value)
            out += """<option value="abstract"%s>abstract""" % is_selected("abstract", value)
            out += """<option value="reportnumber"%s>report number""" % is_selected("reportnumber", value)
            out += """<option value="keyword"%s>keyword""" % is_selected("keyword", value)
        out += """</select>""" 
        return out

    def create_searchexample(self):
        "Produces search example(s) for the current collection."
        out = "$collSearchExamples = getSearchExample(%d, $se);" % self.id
        return out

    def create_searchfor(self):
        "Produces either Simple or Advanced 'Search for' box for the current collection."
        return """ <?
        $collNbDocs = GetNbDocInCollection("%s", "<strong>", " records</strong>"); 
        %s
        if ($as==1) {
           print <<<END_OF_ADVANCEDSEARCHFOR
           %s
END_OF_ADVANCEDSEARCHFOR;
        } else {
           print <<<END_OF_SIMPLESEARCHFOR
           %s
END_OF_SIMPLESEARCHFOR;
        }
        ?> """ % (self.name, self.create_searchexample(), self.create_searchfor_advanced(), self.create_searchfor_simple())

    def create_searchfor_simple(self):
        "Produces simple 'Search for' box for the current collection."
        # print commentary start:
        out = "<!--create_searchfor_simple()-->"
        # define URL add-ons for simple and advanced search boxen:
        ssearchurl = "?as=0"
        asearchurl = "?as=1"
        # define search box elements:
        cell_1_left = """<small><strong>Search $collNbDocs for:</strong></small>
                         <br><input type="text" name="p" size="40" value="">"""
        cell_1_middle = "<small><strong>within:</strong></small><br>%s" % self.create_searchwithin_selection_box()
        cell_1_right = """<input type="submit" name="search" value="SEARCH"><input type="submit" name="search" value="Browse">&nbsp;"""
        cell_1_farright = """<small class="light"><a href="%s">Advanced Search</a></small>
                             <br><small><a href="%s/docs/faq.shtml">Search Tips</a></small>""" % (asearchurl, weburl)
        cell_2 = "$collSearchExamples"
        # merge them:
        out += """<table>
                    <tr valign="bottom">
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                      <td align="left">%s</td>
                    </tr>
                    <tr valign="baseline">
                      <td colspan="4">%s</td>
                    </tr>
                   </table>""" % \
              (cell_1_left, cell_1_middle, cell_1_right, cell_1_farright, cell_2)
        # print commentary end:
        out += "<!--/create_searchfor_simple()-->"
        return out

    def create_searchfor_advanced(self):
        "Produces simple 'Search for' box for the current collection."
        # print commentary start:
        out = "<!--create_searchfor_advanced()-->"
        out += """<input type="hidden" name="as" value="1">"""
        # define URL add-ons for simple and advanced search boxen:
        ssearchurl = "?as=0"
        asearchurl = "?as=1"
        # define search box elements:
        cell_1_left = """<small><strong>Search $collNbDocs for:</strong></small><br>""" + \
                      create_matchtype_box('m1') + """<input type="text" name="p1" size="40" value="">"""
        cell_1_middle = "<small><strong>within:</strong></small><br>%s" % self.create_searchwithin_selection_box('f1')
        cell_1_right = create_andornot_box('op1')
        cell_1_farright = ""
        cell_2_left = create_matchtype_box('m2') + """<input type="text" name="p2" size="40" value="">"""
        cell_2_middle = self.create_searchwithin_selection_box('f2')
        cell_2_right = create_andornot_box('op2')
        cell_2_farright = ""
        cell_3_left = create_matchtype_box('m3') + """<input type="text" name="p3" size="40" value="">"""
        cell_3_middle = self.create_searchwithin_selection_box('f3')
        cell_3_right = """<input type="submit" name="search" value="SEARCH"><input type="submit" name="search" value="Browse">&nbsp;"""
        cell_3_farright = """<small class="light"><a href="%s">Simple Search</a></small>
                             <br><small><a href="%s/docs/faq.shtml">Search Tips</a></small>""" % (ssearchurl, weburl)
        cell_4 = "$collSearchExamples"
        # merge them:
        out += """<table>
                    <tr valign="bottom">
                      <td nowrap>%s</td>
                      <td>%s</td>
                      <td>%s</td>
                      <td>%s</td>
                    </tr>
                    <tr valign="bottom">
                      <td nowrap>%s</td>
                      <td>%s</td>
                      <td>%s</td>
                      <td>%s</td>
                    </tr>
                    <tr valign="bottom">
                      <td nowrap>%s</td>
                      <td>%s</td>
                      <td nowrap>%s</td>
                      <td nowrap>%s</td>
                    </tr>
                    <tr valign="baseline">
                      <td colspan="4">%s</td>
                    </tr>
                   </table>""" % \
              (cell_1_left, cell_1_middle, cell_1_right, cell_1_farright, \
               cell_2_left, cell_2_middle, cell_2_right, cell_2_farright, \
               cell_3_left, cell_3_middle, cell_3_right, cell_3_farright, \
               cell_4)
        # print commentary end:
        out += "<!--/create_searchfor_advanced()-->"
        return out

    def calculate_recinfo(self):
        "Calculates the reclist universe for given collection."
        reclist = HitList()
        if not self.dbquery:
            # A - collection does not have dbquery, so query recursively all its sons:
            for coll in self.get_sons():
                reclist.union(coll.calculate_recinfo())
        else:
            # B - collection does have dbquery, so compute and return number of documents found:
            reclist = search_pattern(None,self.dbquery)
        reclist.calculate_nbhits()
        return reclist

    def update_recinfo(self):
        "Updates the reclist column of the collections table."
        print "==> %s [id=%d]" % (self.name, self.id)
        print "...... updating records:",
        sys.stdout.flush()
        reclist = self.calculate_recinfo()
        self.nbrecs = reclist._nbhits
        self.reclist = reclist._set
        try:
            query = "UPDATE collection SET nbrecs=%d, reclist='%s' WHERE id=%d" % \
                    (self.nbrecs, escape_string(zlib.compress(Numeric.dumps(self.reclist))), self.id)
            res = run_sql(query)
        except MySQLdb.Error, e:
            print "Database Query Error %d: %s." % (e.args[0], e.args[1])
            sys.exit(1)            
        print "%d found" % self.nbrecs

def usage(code, msg=''):
    "Prints usage info."
    if msg:
        sys.stderr.write("Error: %s.\n" % msg)
    sys.stderr.write("Usage: %s [collection][+]\n" % sys.argv[0])
    sys.stderr.write("""Description: %s creates the collection pages
    hierarchy for the CDS document server, based on WML and MySQL
    configuration parameters.  If no options are passed, it'll
    recreate all the collections.  If the collection name is passed as
    the first argument, it'll recreate this collection.  If the
    collection name is immediately followed by a plus sign, it will
    create also the pages for all collection desdendants.  The
    top-level collection name may be entered as the void string.\n""" % sys.argv[0])    
    sys.stderr.write("Example: %s\n" % sys.argv[0])
    sys.stderr.write("Example: %s \"Articles & Preprints\"\n" % sys.argv[0])
    sys.stderr.write("Example: %s \"Articles & Preprints\"+\n" % sys.argv[0])
    sys.stderr.write("Example: %s \"\"\n" % sys.argv[0])
    sys.stderr.write("Example: %s \"\"+\n" % sys.argv[0])
    sys.exit(code)

def main():
    "Main function to call creation of collection pages.  Arguments described in usage() function."
    # firstly, try to read arguments:
    
    if len(sys.argv) == 1:
        ## case A: we'll do all the collections 
        query = """SELECT name FROM collection ORDER BY id"""
        res = run_sql(query)
        for row in res:
            col = Collection(row[0])
            col.update_recinfo()
            col.create_page()                    
    elif len(sys.argv) == 2:
        ## case B: we'll do only selected collection (and eventually its descendants)
        coll_sons_too = 0 # we don't treat collection descendants by default
        coll_name = sys.argv[1] 
        if coll_name[-1:] == '+':
            # yes we do the descendants too
            coll_name = coll_name[:-1]
            coll_sons_too = 1
        # now treat the page in question:
        col = Collection(coll_name)
        if col.id == None:
            usage(1, 'Collection %s does not exist' % coll_name)
        col.update_recinfo()
        col.create_page()
        # now treat all its descendants, eventually:
        if coll_sons_too:
            for col_desc in col.get_descendants():
                col_desc.update_recinfo()
                col_desc.create_page()
    else:
        ## case C: bad arguments
        usage(1)

def test_calculate_recinfo():
    "Test function that creates bit vector of records."
    col = Collection("Preprints")
    print col.name
    reclist = col.calculate_recinfo() 
    print "%d records" % reclist._nbhits

### okay, here we go:
if __name__ == '__main__':    
    #test_calculate_recinfo()
    main()
